<!DOCTYPE html>
<html>
<head>
    <!--
    * Author:         BeiYuu
    -->
    <meta charset="utf-8" />
    <title>ONOS 强一致性算法raft的java实现版copycat说明 | kailongli.github.io</title>
    <meta name="author" content="KailongLi" />
    <meta name="renderer" content="webkit">
    <meta name="description" content="KailongLi's Blog" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0">
    <link rel="stylesheet" href="/css/default.css" type="text/css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon" />
    <link rel="alternate" type="application/atom+xml" title="Recent Entries" href="/atom.xml" />
    <script src="/js/jquery-1.7.1.min.js" type="text/javascript"></script>
</head>
<body>

    <div class="home-menu">
        <div class="home-icon-con">
            <a class="home-menu-icon" href="/">李开龙</a>
            <a class="home-follow" href="#" title="Contact Me">+</a>
        </div>
        <div class="home-contact">
            <a href="http://weibo.com/beiyuu/" target="_blank" style="margin-left:-5px;"><img src="http://www.weibo.com/favicon.ico" alt="" width="25"/></a>
            <a href="http://www.douban.com/people/beiyuu/" target="_blank" style="text-align:center;"><img src="http://www.douban.com/favicon.ico" alt="" width="22"/></a>
            <a href="http://instagram.com/beiyuu/" target="_blank" style="text-align:right"><img src="http://d36xtkk24g8jdx.cloudfront.net/bluebar/00c6602/images/ico/favicon.ico" alt="" width="22"/></a>
        </div>
    </div>

    <link rel="stylesheet" href="/js/prettify/prettify.css" />
<style type="text/css">
    body { background:#e8e8e8; }
    @media screen and (max-width: 750px){
        body { background:#fff; }
    }
    @media screen and (max-width: 1020px){
        body { background:#fff; }
    }
</style>

<div id="content">
    <div class="entry">
        <h1 class="entry-title"><a href="/raft-copycat" title="ONOS 强一致性算法raft的java实现版copycat说明">ONOS 强一致性算法raft的java实现版copycat说明</a></h1>
        <p class="entry-date">2015-06-09</p>
        <h1>Copycat</h1>

<p><a href="https://travis-ci.org/kuujo/copycat"><img src="https://travis-ci.org/kuujo/copycat.png" alt="Build Status" /></a></p>

<p>Copycat is an extensible distributed coordination framework for Java 8 built on the
<a href="https://raftconsensus.github.io/">Raft consensus protocol</a>.</p>

<p><strong>Over the past couple months, Copycat has undergone significant development in preparation for an initial release.
That release is tentatively planned for June 21st!</strong></p>

<p>The first release of Copycat will feature:
* High-level path-based resource API
* A well-tested standalone Raft implementation
* Support for distributed events, messaging, and remote task execution
* Essential distributed collections, e.g. map, set, list
* Essential distributed atomic variables, e.g. atomic boolean, long, and reference
* Essential distributed coordination utilities, e.g. locks and leader elections
* Support for time and session based features, including expiring or ephemeral keys
* Support for arbitrary custom resources</p>

<p>The first release of Copycat will also include a number of essential improvements:
* Friendly builder API for <code>Cluster</code> and <code>Raft</code>
* Support for client-only nodes
* Linearizable Raft clients via sessions
* Significant improvements to internal log with efficient compaction algorithm
* Low-level buffer abstraction for off-heap memory and disk I/O
* An efficient custom serialization framework</p>

<p>The current development branch is <code>0.6.0</code>. We expect these changes to be merged into the <code>master</code> branch and pushed to
Maven central in the coming days and weeks.</p>

<p><strong>Note that due to the impending changes, much of the existing documentation is obsolete. Check back soon for new documentation!</strong></p>

<h2>Deprecated</h2>

<p>Copycat is a CP (consistent/partition-tolerant) oriented exercise in distributed coordination built on a consistent
replicated log. The core of Copycat is an extensible asynchronous framework that uses a mixture of
<a href="http://en.wikipedia.org/wiki/Gossip_protocol">gossip</a> and the <a href="https://raftconsensus.github.io/">Raft consensus protocol</a>
to provide a set of high level APIs that solve a variety of distributed systems problems including:
* <a href="#leader-elections">Leader election</a>
* <a href="#state-machines">Replicated state machines</a>
* <a href="#state-logs">Strongly consistent state logs</a>
* <a href="#event-logs">Eventually consistent event logs</a>
* <a href="#collections">Distributed collections</a>
* <a href="#failure-detection">Failure detection</a>
* <a href="#remote-execution">Remote execution</a></p>

<p><em>Copycat requires Java 8</em></p>

<h1>User Manual</h1>

<ol>
<li><a href="#introduction">Introduction</a></li>
<li><a href="#getting-started">Getting started</a>

<ul>
<li><a href="#thread-safety">Thread safety</a></li>
<li><a href="#setting-up-the-cluster">Setting up the cluster</a></li>
<li><a href="#configuring-the-protocol">Configuring the protocol</a></li>
<li><a href="#creating-a-copycat-instance">Creating a Copycat instance</a></li>
<li><a href="#accessing-the-copycat-cluster">Accessing the Copycat cluster</a></li>
</ul>
</li>
<li><a href="#configuration">Configuration</a>

<ul>
<li><a href="#configuration-files">Configuration files</a></li>
<li><a href="#configuration-objects">Configuration objects</a></li>
</ul>
</li>
<li><a href="#resources">Resources</a>

<ul>
<li><a href="#resource-lifecycle">Resource lifecycle</a></li>
<li><a href="#configuring-resources">Configuring resources</a>

<ul>
<li><a href="#resource-replicas">Resource replicas</a></li>
<li><a href="#log-configuration">Log configuration</a></li>
<li><a href="#serialization">Serialization</a></li>
<li><a href="#executors">Executors</a></li>
<li><a href="#resource-configuration-files">Resource configuration files</a></li>
</ul>
</li>
<li><a href="#creating-resources">Creating resources</a></li>
<li><a href="#resource-clusters">Resource clusters</a></li>
</ul>
</li>
<li><a href="#state-machines">State machines</a>

<ul>
<li><a href="#creating-a-state-machine">Creating a state machine</a></li>
<li><a href="#creating-a-state-machine-as-a-standalone-service">Creating a standalone state machine</a></li>
<li><a href="#configuring-the-state-machine">Configuring the state machine</a></li>
<li><a href="#designing-state-machine-states">Designing state machine states</a></li>
<li><a href="#state-machine-commands">State machine commands</a></li>
<li><a href="#state-machine-queries">State machine queries</a></li>
<li><a href="#the-state-context">The state context</a></li>
<li><a href="#transitioning-the-state-machine-state">Transitioning the state machine state</a></li>
<li><a href="#synchronous-proxies">Synchronous proxies</a></li>
<li><a href="#asynchronous-proxies">Asynchronous proxies</a></li>
</ul>
</li>
<li><a href="#event-logs">Event logs</a>

<ul>
<li><a href="#creating-an-event-log">Creating an event log</a></li>
<li><a href="#event-log-configuration">Event log configuration</a></li>
<li><a href="#writing-events-to-the-event-log">Writing events to the event log</a></li>
<li><a href="#consuming-events-from-the-event-log">Consuming events from the event log</a></li>
</ul>
</li>
<li><a href="#state-logs">State logs</a>

<ul>
<li><a href="#creating-a-state-log">Creating a state log</a></li>
<li><a href="#state-log-configuration">State log configuration</a></li>
<li><a href="#state-commands">State commands</a></li>
<li><a href="#state-queries">State queries</a></li>
<li><a href="#submitting-operations-to-the-state-log">Submitting operations to the state log</a></li>
<li><a href="#snapshotting">Snapshotting</a></li>
</ul>
</li>
<li><a href="#leader-elections">Leader elections</a>

<ul>
<li><a href="#creating-a-leader-election">Creating a leader election</a></li>
</ul>
</li>
<li><a href="#collections">Collections</a>

<ul>
<li><a href="#asyncmap">AsyncMap</a></li>
<li><a href="#asynclist">AsyncList</a></li>
<li><a href="#asyncset">AsyncSet</a></li>
<li><a href="#asyncmultimap">AsyncMultiMap</a></li>
<li><a href="#asynclock">AsyncLock</a></li>
</ul>
</li>
<li><a href="#the-copycat-cluster">The Copycat cluster</a>

<ul>
<li><a href="#members">Members</a>

<ul>
<li><a href="#active-members">Active members</a></li>
<li><a href="#passive-members">Passive members</a></li>
<li><a href="#member-states">Member states</a></li>
</ul>
</li>
<li><a href="#leader-election">Leader election</a></li>
<li><a href="#direct-messaging">Direct messaging</a></li>
<li><a href="#broadcast-messaging">Broadcast messaging</a></li>
<li><a href="#remote-execution">Remote execution</a></li>
</ul>
</li>
<li><a href="#protocols">Protocols</a>

<ul>
<li><a href="#the-local-protocol">The local protocol</a></li>
<li><a href="#netty-protocol">Netty protocol</a></li>
<li><a href="#vertx-protocol">Vert.x protocol</a></li>
<li><a href="#vertx-3-protocol">Vert.x 3 protocol</a></li>
</ul>
</li>
<li><a href="#architecture">Architecture</a>

<ul>
<li><a href="#logs">Logs</a></li>
<li><a href="#strong-consistency-and-copycats-raft-consensus-protocol">Strong consistency and Copycat's Raft consensus protocol</a>

<ul>
<li><a href="#leader-election-1">Leader election</a></li>
<li><a href="#command-replication">Write replication</a></li>
<li><a href="#query-consistency">Read consistency</a></li>
<li><a href="#log-compaction">Log compaction</a></li>
</ul>
</li>
<li><a href="#eventual-consistency-and-copycats-gossip-protocol">Eventual consistency and Copycat's gossip protocol</a>

<ul>
<li><a href="#passive-membership">Passive membership</a></li>
<li><a href="#log-replication">Log replication</a></li>
<li><a href="#failure-detection">Failure detection</a></li>
</ul>
</li>
</ul>
</li>
</ol>


<h2>Introduction</h2>

<p>Copycat is a distributed coordination framework built on the
<a href="https://raftconsensus.github.io/">Raft consensus protocol</a>. Copycat facilitates numerous types of strongly consistent
distributed data structures - referred to as <a href="#resources">resources</a> - based on a replicated log. Each Copycat
cluster can support multiple resources, and each resource within a cluster runs a separate instance of the consensus
algorithm to perform leader election and log replication.</p>

<p>The Copycat <a href="#the-copycat-cluster">cluster</a> consists of a core set of <a href="#active-members">active members</a> which
participate in the <a href="#strong-consistency-and-the-raft-consensus-algorithm">Raft leader election and replication protocol</a>
and perform all synchronous replication. Additionally, the cluster may contain a set of additional
<a href="#passive-members">passive members</a> which can be added and removed from the cluster dynamically. While active members
participate in replication of logs via Raft, passive members
<a href="#eventual-consistency-and-copycats-gossip-protocol">perform replication asynchronously using a simple gossip protocol</a>.</p>

<p>The following image demonstrates the relationship between active and passive members in the Copycat cluster:</p>

<p><img src="http://s23.postimg.org/i8xyzg2ez/Copycat_Cluster_New_Page_2.png" alt="Copycat cluster" /></p>

<p>Active members participate in synchronous log replication via the Raft consensus protocol and ultimately gossip
committed log entries to passive members, while passive members gossip among each other.</p>

<p>For more information on Copycat's leader election and replication implementation see the in depth explanation of
<a href="#architecture">Copycat's architecture</a>.</p>

<p>In addition to supporting multiple resources within the same cluster, Copycat supports different cluster configurations
on a per-resource basis. This allows Copycat's resources to be optimized by partitioning resources and assigning
different partitions to different members in the cluster.</p>

<p>The following image depicts the partitioning of resources across the Copycat cluster:</p>

<p>Each <a href="#resources">resource</a> in the cluster has its own related logical <code>Cluster</code> through which it communicates with
other members of the <a href="#resource-clusters">resource's cluster</a>. Just as each resource performs replication for its
associated <a href="#logs">log</a>, so too does each resource cluster perform leader elections independently of other resources
in the cluster. Additionally, Copycat's global and resource clusters can be used to send arbitrary messages between
members of the cluster or execute tasks on members remotely.</p>

<h2>Getting started</h2>

<p>The Copycat project is structured as several Maven submodules.</p>

<p>The primary module for Copycat is the <code>copycat-api</code> module. The Copycat API module aggregates all of the resource
modules into a single API, and allows multiple distributed resources to be created within a single Copycat instance.</p>

<pre><code>&lt;dependency&gt;
  &lt;groupId&gt;net.kuujo.copycat&lt;/groupId&gt;
  &lt;artifactId&gt;copycat-api&lt;/artifactId&gt;
  &lt;version&gt;0.5.0-SNAPSHOT&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>

<p>Additionally, the following resource modules are provided:
* <code>copycat-event-log</code> - A replicated log designed for recording event histories
* <code>copycat-state-log</code> - A replicated log designed for strongly consistent recording of state machine
  command histories
* <code>copycat-state-machine</code> - A replicated state machine framework built on top of <code>copycat-state-log</code> using proxies
* <code>copycat-leader-election</code> - A simple leader election framework built on top of <code>copycat-state-log</code>
* <code>copycat-collections</code> - A set of strongly consistent distributed collection APIs built on top of <code>copycat-state-log</code></p>

<p>Each of the Copycat resource modules can be used independently of one another and independently of the high level
<code>copycat-api</code>.</p>

<h4>Thread safety</h4>

<p>All of Copycat's user-facing APIs are thread safe. Additionally, each of Copycat's <a href="#resources">resources</a> and their
related <a href="#resource-clusters">clusters</a> are executed on a single thread-per-resource.</p>

<h3>Configuring the protocol</h3>

<p>Copycat supports a pluggable protocol that allows developers to integrate a variety of frameworks into the Copycat
cluster. Each Copycat cluster must specific a <code>Protocol</code> in the cluster's <code>ClusterConfig</code>. For more information
see the section on <a href="#protocols">protocols</a>.</p>

<pre><code class="java">ClusterConfig cluster = new ClusterConfig()
  .withProtocol(new NettyTcpProtocol());
</code></pre>

<p>Alternatively, users can override the default protocol by overriding <code>cluster-defaults.conf</code> with <code>cluster.conf</code>.</p>

<p><code>cluster.conf</code></p>

<pre><code>protocol {
  class: net.kuujo.copycat.netty.NettyTcpProtocol
  send.buffer.size: 8192
  receive.buffer.size: 8192
}
</code></pre>

<p>Copycat core protocol implementations include <a href="#netty-protocol">Netty</a>, <a href="#vertx">Vert.x</a>, and <a href="vertx-3">Vert.x 3</a>.
Each protocol implementation is separated into an independent module which can be added as a Maven dependency.</p>

<pre><code>&lt;dependency&gt;
  &lt;groupId&gt;net.kuujo.copycat&lt;/groupId&gt;
  &lt;artifactId&gt;copycat-netty&lt;/artifactId&gt;
  &lt;version&gt;0.5.0-SNAPSHOT&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>

<p>The <code>copycat-core</code> module also contains a <code>LocalProtocol</code> which can be used for multi-threaded testing. When using
the <code>LocalProtocol</code> for testing, you should use the same <code>LocalProtocol</code> instance across all test instances.</p>

<h3>Setting up the cluster</h3>

<p>In order to connect your <code>Copycat</code> instance to <a href="#the-copycat-cluster">the Copycat cluster</a>, you must add a set of
protocol-specific URIs to the <code>ClusterConfig</code>. The cluster configuration specifies how to find the <em>active</em> members -
the core voting members of the Copycat cluster - by defining a simple list of active members URIs. Passive members are
not defined in the cluster configuration. Rather, they are added dynamically to the cluster via a gossip protocol.
For more about active members see the section on <a href="#active-members">cluster members</a>.</p>

<pre><code class="java">ClusterConfig cluster = new ClusterConfig()
  .withProtocol(new VertxTcpProtocol())
  .withLocalMember("tcp://123.456.789.0:1234")
  .withMembers("tcp://123.456.789.0:1234", "tcp://123.456.789.1:1234", "tcp://123.456.789.2:1234");
</code></pre>

<p>Note that the cluster's <code>local-member</code> attribute <em>must be defined</em>, but it does not have to be represented in the list
of configured active members. If the local member is not in the active members list, the node will join the cluster as
a <em>passive</em> member.</p>

<p>Alternatively, users can configure the cluster by overriding the default cluster configuration with a <code>cluster.conf</code>
<a href="https://github.com/typesafehub/config">Typesafe configuration</a> file:</p>

<p><code>cluster.conf</code></p>

<pre><code>protocol {
  class: net.kuujo.copycat.vertx.VertxTcpProtocol
  connect.timeout: 30000
}

members: [
  "tcp://123.456.789.0:1234"
  "tcp://123.456.789.1:1234"
  "tcp://123.456.789.2:1234"
]
</code></pre>

<p>Note that member URIs must be unique and all members of the cluster must agree with the configured protocol. Member URIs
will be checked at configuration time for validity.</p>

<p>Because of the design of the <a href="#strong-consistency-and-copycats-raft-consensus-protocol">Raft algorithm</a>, it is strongly
recommended that any Copycat cluster have <em>at least three active voting members</em>. Raft requires a majority of the
cluster to be available in order to accept writes. Since passive members don't participate in the Raft protocol, only
active members contribute towards this membership count. So, for instance, a cluster of three active members can
tolerate one failure, a cluster of five active members can tolerate two failures, and so on.</p>

<h3>Creating a Copycat instance</h3>

<p>To create a <code>Copycat</code> instance, call one of the overloaded <code>Copycat.create()</code> methods:
* <code>Copycat.create()</code> - creates a Copycat instance with the file-based cluster configuration
* <code>Copycat.create(ClusterConfig cluster)</code> - creates a Copycat instance with a custom cluster configuration
* <code>Copycat.create(CopycatConfig config)</code> - create a Copycat instance with a custom configuration</p>

<p>Note that the first argument to any <code>Copycat.create()</code> method is a <code>uri</code>. This is the protocol specific URI of the
<em>local</em> member, and it may or may not be a member defined in the provided <code>ClusterConfig</code>. This is because Copycat
actually supports eventually consistent replication for clusters much larger than the core Raft cluster - the cluster
of <em>active</em> members defined in the cluster configuration.</p>

<pre><code class="java">Copycat copycat = Copycat.create(cluster);
</code></pre>

<p>When a <code>Copycat</code> instance is constructed, a central replicated state machine is created for the entire Copycat cluster.
This state machine is responsible for maintaining the state of all <a href="#resources">cluster resources</a>. In other words, it
acts as a central registry for other log based structures created within the cluster. This allows Copycat to
coordinate the creation, usage, and deletion of multiple log-based resources within the same cluster.</p>

<p>Once the <code>Copycat</code> instance has been created, you must open the <code>Copycat</code> instance by calling the <code>open</code> method.</p>

<pre><code class="java">CompletableFuture&lt;Copycat&gt; future = copycat.open();
future.get();
</code></pre>

<p>When the <code>Copycat</code> instance is opened, all the <a href="#resources">resources</a> defined in the
<a href="#configuring-resources">configuration</a> will be opened and begin participating in leader election and log replication.</p>

<h3>Accessing the Copycat cluster</h3>

<p>Each <code>Copycat</code> instance contains a reference to the global <code>Cluster</code>. The cluster handles communication between
Copycat instances and provides a vehicle through which users can <a href="#messaging">communicate</a> with other Copycat instances
as well. To get a copy of the Copycat <code>Cluster</code> simply call the <code>cluster</code> getter on the <code>Copycat</code> instance.</p>

<pre><code class="java">Cluster cluster = copycat.cluster();
</code></pre>

<p>For more information on using the <code>Cluster</code> object to communicate with other members of the cluster see the section
on <a href="#the-copycat-cluster">the Copycat cluster</a>.</p>

<h2>Configuration</h2>

<p>All Copycat configuration types - <code>CopycatConfig</code>, <code>ClusterConfig</code>, <code>ResourceConfig</code>, etc - are backed by the excellent
<a href="https://github.com/typesafehub/config">Typesafe Config</a> library.</p>

<p>Configuration for all configurable objects - cluster, logs, resources, and serializers - are backed by default
configuration files. Configurations use a hierarchical resolution process that allows users to override portions of
configurations by defining specifically named configuration files. In the documentation that follows, each section
regarding a configurable type will indicate how configurations can be overridden.</p>

<p>In general, all configurations are resolved with the following precedence:
* Code based configuration (e.g. <code>eventLogConfig.withRetentionPolicy(new SizeBasedRetentionPolicy(1024 * 1024));</code>)
* User defined file-based configuration (e.g. <code>my-event-log.conf</code>)
* Type specific file configuration (e.g. <code>event-log.conf</code>, <code>resource.conf</code>)
* Default type specific file configuration (e.g. <code>event-log-defaults.conf</code>, <code>resource-defaults.conf</code>)</p>

<p>Additionally, Copycat's configuration resolution process supports namespaced configurations for all configurable types.
So, users can define configuration namespaces by separating configuration sections in the resource name with a <code>.</code>. For
example, <code>new StateMachineConfig("foo.bar.baz")</code> will search for and resolve configuration files in the following order:
* <code>foo.bar.baz.conf</code>
* <code>foo.bar.conf</code>
* <code>foo.conf</code>
* <code>state-machine.conf</code>
* <code>state-machine-defaults.conf</code>
* <code>state-log.conf</code>
* <code>state-log-defaults.conf</code>
* <code>resource.conf</code>
* <code>resource-defaults.conf</code></p>

<p>Additionally, configurable resources referenced within the given configuration will be resolved in a similar order.
For instance, the state machine's underlying <code>Log</code> will be resolved in the following order:
* The <code>log</code> section of <code>foo.bar.baz.conf</code>
* The <code>log</code> section of <code>foo.bar.conf</code>
* The <code>log</code> section of <code>foo.conf</code>
* The <code>log</code> section of <code>state-machine.conf</code>
* The <code>log</code> section of <code>state-machine-defaults.conf</code>
* The <code>log</code> section of <code>state-log.conf</code>
* The <code>log</code> section of <code>state-log-defaults.conf</code>
* <code>log.conf</code>
* <code>log-defaults.conf</code></p>

<p>To learn more about Copycat's configuration format, users are encouraged to read the
<a href="https://github.com/typesafehub/config">Typesafe Config documentation</a> and particularly the
<a href="https://github.com/typesafehub/config/blob/master/HOCON.md">HOCON configuration format</a></p>

<h2>Resources</h2>

<p>Each Copycat instance can support any number of various named resources. <em>Resource</em> is an abstract term for all of the
high level log-based data types provided by Copycat. Ultimately, each resource - whether is be an
<a href="#event-logs">event log</a>, <a href="#state-logs">state log</a>, <a href="#state-machines">state machine</a>, or <a href="#collections">collection</a> -
is backed by a Raft replicated <a href="#logs">log</a> that is managed by the Copycat cluster coordinator internally.</p>

<h3>Resource lifecycle</h3>

<p>When a Copycat instance is created and opened, any resources for which the local <code>Copycat</code> instance is listed as a
replica will be opened internally and immediately begin participating in leader election and replication for that
resource. Leader election and replication for resources occur separately from the global Copycat cluster. Therefore,
the leader for a given resource may frequently differ from the global Copycat cluster leader. This ensures that Copycat
can maintain consistency across multiple resources within the same cluster.</p>

<h3>Configuring resources</h3>

<p>Each of Copycat's resource types - <code>EventLog</code>, <code>StateLog</code>, <code>StateMachine</code>, etc - has an associated <code>Config</code> class.
This configuration class is used to configure various attributes of the resource, including Raft-specific configuration
options such as election timeouts and heartbeat intervals as well as resource specific configuration options. Each of
these configuration classes can be used to configure their respective resources when the resources are created</p>

<pre><code class="java">EventLogConfig config = new EventLogConfig()
  .withSerializer(KryoSerializer.class)
  .withLog(new FileLog()
    .withSegmentSize(1024 * 1024));

EventLog&lt;String&gt; eventLog = copycat.createEventLog("event-log", config);
</code></pre>

<p>Each resource can optionally define a set of replicas separate from the global cluster configuration. The set of
replicas in the resource configuration <em>must be contained within the set of active members defined in the cluster
configuration</em>. The resource's replica set defines the members that should participate in leader election and
synchronous replication for the resource. Therefore, in a five node Copycat cluster, if a resource is configured with
only three replicas, writes will only need to be persisted on two nodes in order to be successful.</p>

<pre><code class="java">CopycatConfig config = new CopycatConfig()
  .withClusterConfig(new ClusterConfig()
    .withProtocol(new NettyTcpProtocol())
    .withLocalMember("tcp://123.456.789.1:1234")
    .withMembers(
      "tcp://123.456.789.0:1234",
      "tcp://123.456.789.1:1234",
      "tcp://123.456.789.2:1234",
      "tcp://123.456.789.3:1234",
      "tcp://123.456.789.4:1234"
    ));

Copycat copycat = Copycat.create(config).open().get();

EventLogConfig eventLogConfig = new EventLogConfig()
  .withSerializer(KryoSerializer.class)
  .withReplicas("tcp://123.456.789.1:1234", "tcp://123.456.789.2:1234", "tcp://123.456.789.3:1234")
  .withLog(new FileLog()
    .withSegmentSize(1024 * 1024));

EventLog&lt;String&gt; eventLog = copycat.createEventLog("event-log", eventLogConfig);
</code></pre>

<p>If replicas are defined for the resource and the local cluster member is not specified in the list of resource members,
the local resource will join the clustered resource as a <em>passive</em> member of the resource.</p>

<h4>Resource replicas</h4>

<p>Each of the resources in Copycat's cluster do not have to be replicated on all <a href="#active-members">active members</a> on
the core cluster. Instead, Copycat allows replicas to be configured on a per-resource basis. This allows users to
configure replication for a specific resource on a subset of the core cluster of active members.</p>

<pre><code class="java">CopycatConfig config = new CopycatConfig()
  .withClusterConfig(new ClusterConfig()
    .withMembers(
      "tcp://123.456.789.0:5000",
      "tcp://123.456.789.1:5000",
      "tcp://123.456.789.2:5000",
      "tcp://123.456.789.3:5000",
      "tcp://123.456.789.4:5000"));

EventLogConfig eventLogConfig = new EventLogConfig()
  .withReplicas(
    "tcp://123.456.789.1:5000",
    "tcp://123.456.789.2:5000",
    "tcp://123.456.789.3:5000"));
</code></pre>

<h4>Log configuration</h4>

<p>Each replica of each resource in the Copycat cluster writes to a separate, configurable log. Logs are defined in the
resource configuration via the <code>setLog</code> and <code>withLog</code> methods. Copycat provides several different log implementations
for different use cases:
* <code>FileLog</code> - A simple <code>FileChannel</code> based log. This is the default log for most Copycat data structures.
* <code>BufferedLog</code> - An in-memory log implementation built on <code>TreeMap</code>.
* <code>ChronicleLog</code> - A very efficient <a href="https://github.com/OpenHFT/Chronicle-Queue">Chronicle Queue</a> based log.</p>

<p>Many resource configuration options involve configuring the log itself. Users can configure the performance and
reliability of all Copycat logs by tuning the underlying file log configuration options, for instance, by configuring
the frequency with which Copycat flushes logs to disk.</p>

<pre><code class="java">EventLogConfig config = new EventLogConfig()
  .withLog(new FileLog()
    .withFlushInterval(60, TimeUnit.SECONDS));
</code></pre>

<p>Additionally, configurations for all logs or for specific logs can be overridden via
<a href="https://github.com/typesafehub/config">Typesafe configuration</a> files. To override the default configuration for all
logs, define a <code>log.conf</code> configuration resource on the classpath. Alternatively, to configure a named log define
a configuration resource (i.e. <code>*.conf</code>, <code>*.json</code>, or <code>*.properties</code>) on the classpath and reference that resource
when constructing the log. For example:</p>

<p><code>my-log.conf</code></p>

<pre><code>segment.interval: 60000
flush.on-write: true
</code></pre>

<p>Given a custom configuration resource on the classpath, simply pass that resource name to the log constructor:</p>

<pre><code class="java">EventLogConfig config = new EventLogConfig()
  .withLog(new FileLog("my-log"));
</code></pre>

<p>Log configurations are resolved with the following order of precedence:
* Code based configuration
* Custom file based configuration
* <code>log.conf</code>, <code>log.json</code>, or <code>log.properties</code>
* <code>log-defaults.conf</code></p>

<p>Additionally, log configurations can be overridden within resource configuration files as well.</p>

<pre><code>log {
  class: net.kuujo.copycat.log.FileLog
  segment.interval: 60000
  flush.on-write: true
}
</code></pre>

<h4>Serialization</h4>

<p>By default, entries to Copycat's logs are serialized using the default <a href="https://github.com/EsotericSoftware/kryo">Kryo</a>
based serializer, so users can implement custom serializer for log entries by implementing <code>KryoSerializable</code>:</p>

<pre><code class="java">public class MyEntry implements KryoSerializable {

  public void write (Kryo kryo, Output output) {
    // ...
  }

  public void read (Kryo kryo, Input input) {
     // ...
  }
}
</code></pre>

<p>To register custom classes for serialization by the Kryo serializer, create a <code>serializer.conf</code> on the classpath and
define classes and their IDs in the <code>registrations</code> object:</p>

<p><code>serializer.conf</code></p>

<pre><code>registrations.1 = com.mycompany.myproject.MySerializableClass
registrations.2 = com.mycompant.myproject.OtherSerializableClass
</code></pre>

<p>In order to ensure portability between members, it's important that all nodes in the Copycat cluster contain the same
registrations with the same identifiers.</p>

<p>Serializer configurations can also be specified on a per-resource basis:</p>

<p><code>my-resource.conf</code></p>

<pre><code>serializer {
  class: net.kuujo.copycat.util.serializer.KryoSerializer
  registrations {
    1: com.mycompany.myproject.MySerializableClass
    2: com.mycompany.myproject.OtherSerializableClass
  }
}
</code></pre>

<h4>Executors</h4>

<p>Copycat makes heavy use of Java 8's <code>CompletableFuture</code>. Each Copycat resource guarantees that completable future
callbacks will be executed on the same thread-per-resource. However, in some cases the user needs control over the
context in which resource callbacks are executed. For instance, when running Copycat within Vert.x, it can be useful
to execute <code>CompletableFuture</code> callbacks, election result handlers, message handlers, and other callbacks on the
Vert.x event loop. Copycat allows users to configure the <code>Executor</code> used by each resource instance.</p>

<p>To configure the <code>Executor</code> instance for a resource, add the executor to the resource's configuration:</p>

<pre><code class="java">EventLogConfig config = new EventLogConfig()
  .withExecutor(new VertxEventLoopExecutor(vertx));
</code></pre>

<p>All user facing callbacks within the resource and its related <a href="#resource-clusters">cluster</a> will be executed with
the given <code>Executor</code> instance.</p>

<p>To configure the executor for the global Copycat cluster and instance, add an <code>Executor</code> to the <code>CopycatConfig</code>:</p>

<pre><code class="java">CopycatConfig config = new CopycatConfig()
  .withExecutor(new VertxEventLoopExecutor(vertx));
</code></pre>

<p>Note that because of the semantics of threads, executors are the one resource that <em>can not be specified via
configuration files</em>.</p>

<h4>Resource configuration files</h4>

<p>All resource configurations inherit from the base <code>ResourceConfig</code> configuration class. The <code>ResourceConfig</code> receives
defaults from the <code>resource-defaults.conf</code> <a href="https://github.com/typesafehub/config">Typesafe configuration</a> file. To
override default resource configuration options for all resource types, define a <code>resource.conf</code> on the classpath. Any
configuration options specified in <code>resource.conf</code> will override equivalent values defined in <code>resource-defaults.conf</code>.</p>

<p><code>resource.conf</code></p>

<pre><code># Set the default resource log to BufferedLog
log.class: net.kuujo.copycat.log.BufferedLog
</code></pre>

<h3>Creating resources</h3>

<p>With resources configured and the <code>Copycat</code> instance created, resources can be easily retrieved by calling any
of the resource-specific methods on the <code>Copycat</code> instance:
* <code>&lt;T&gt; EventLog&lt;T&gt; createEventLog(String name)</code>
* <code>&lt;T&gt; StateLog&lt;T&gt; createStateLog(String name)</code>
* <code>&lt;T&gt; StateMachine&lt;T&gt; createStateMachine(String name)</code>
* <code>LeaderElection createLeaderElection(String name)</code>
* <code>&lt;K, V&gt; AsyncMap&lt;K, V&gt; createMap(String name)</code>
* <code>&lt;K, V&gt; AsyncMultiMap&lt;K, V&gt; createMultiMap(String name)</code>
* <code>&lt;T&gt; AsyncList&lt;T&gt; createList(String name)</code>
* <code>&lt;T&gt; AsyncSet&lt;T&gt; createSet(String name)</code>
* <code>AsyncLock createLock(String name)</code>
* <code>AsyncLong createLong(String name)</code>
* <code>AsyncBoolean createBoolean(String name)</code>
* <code>AsyncReference createReference(String name)</code></p>

<pre><code class="java">Copycat copycat = Copycat.create(config);

copycat.open().thenRun(() -&gt; {
  StateMachine&lt;String&gt; stateMachine = copycat.createStateMachine("test");
  stateMachine.open().thenRun(() -&gt; {
    Map&lt;String, String&gt; map = stateMachine.createProxy(Map.class);
    map.put("foo", "Hello world!").thenRun(() -&gt; {
      map.get("foo").thenAccept(value -&gt; {
        System.out.println(value);
      });
    });
  });
});
</code></pre>

<p>Java 8's <code>CompletableFuture</code> framework is extremely powerful. For instance, the previous code sample could be rewritten
as so:</p>

<pre><code class="java">Copycat copycat = Copycat.create(config);

copycat.open()
  .thenCompose(copycat.createStateMachine("test").open())
  .thenApply(stateMachine -&gt; stateMachine.createProxy(Map.class))
  .thenAccept(map -&gt; {
    map.put("foo", "Hello world!")
      .thenCompose(v -&gt; map.get("foo"))
      .thenAccept(value -&gt; System.out.println(value));
  });
</code></pre>

<h3>Resource clusters</h3>

<p>In order to ensure consistency across resources, each resource performs leader election and replication separately
from the global <code>Copycat</code> cluster. Additionally, because each resource can be replicated on a separate set of nodes
than that which is defined in the global <code>ClusterConfig</code>, resources maintain a separate membership list as well.
Each resource exposes a separate <code>Cluster</code> instance that contains state regarding the resource's leader election and
membership. This <code>Cluster</code> can be used to communicate with other members in the resource's cluster.</p>

<pre><code class="java">Cluster cluster = stateMachine.cluster();
</code></pre>

<h2>State machines</h2>

<p>The most common use case for consensus algorithms is to support a strongly consistent replicated state machine.
Replicated state machines are similarly an essential feature of Copycat. Copycat provides a unique, proxy based
interface that allows users to operate on state machines either synchronously or asynchronously.</p>

<h3>Creating a state machine</h3>

<p>To create a replicated state machine, you first must design an interface for the state machine states. In this case
we'll use one of Copycat's provided <a href="#collections">collections</a> as an example.</p>

<p>States are used internally by Copycat to apply state machine commands and queries and transition between multiple
logical states. Each state within a state machine must implement a consistent explicitly defined interface. In this
case we're using the existing Java <code>Map</code> interface to define the state.</p>

<pre><code class="java">public class DefaultMapState&lt;K, V&gt; implements Map&lt;K, V&gt; {
  private Map&lt;K, V&gt; map;

  @Initializer
  public void init(StateContext&lt;AsyncMapState&lt;K, V&gt;&gt; context) {
    map = context.get("value");
    if (map == null) {
      map = new HashMap&lt;&gt;();
      context.put("value", map);
    }
  }

  @Override
  public V put(K key, V value) {
    return map.put(key, value);
  }

  @Override
  public V get(K key) {
    return map.get(key);
  }

  @Override
  public V remove(K key) {
    return map.remove(key);
  }

  @Override
  public boolean containsKey(K key) {
    return map.containsKey(key);
  }

}
</code></pre>

<p>The <code>StateContext</code> can be used to store state values that Copycat will use to take snapshots of the state machine state
and compact the replicated log. For this reason, it is essential that state implementations store state in the
<code>StateContext</code>.</p>

<p>Once we've defined the map state, we can simply create a new map state machine via the <code>stateMachine</code> factory method.</p>

<pre><code class="java">CopycatConfig config = new CopycatConfig()
  .withClusterConfig(cluster)
  .addStateMachineConfig("map", new StateMachineConfig()
    .withStateType(Map.class)
    .withInitialState(DefaultMapState.class));

Copycat copycat = Copycat.create(config).open().get();

StateMachine&lt;Map&lt;String, String&gt;&gt; stateMachine = copycat.createStateMachine("map").open().get();
</code></pre>

<p>When a Copycat resource - such as a state machine, log, or election - is created, the resource must be opened before
it can be used. Practically all Copycat interfaces return <code>CompletableFuture</code> instances which can either be used to
block until the result is received or receive the result asynchronously. In this case we just block by calling the
<code>get()</code> method on the <code>CompletableFuture</code>.</p>

<h3>Creating a state machine as a standalone service</h3>

<p>Copycat's architecture is designed such that individual resource types can be used completely independently of others.
The state machine module can be added as a separate Maven dependency, and state machines can be created independent
of the high level <code>Copycat</code> interface which aggregates all resource types into a single component.</p>

<p>To use the state machine as a standalone service, simply add the <code>copycat-state-machine</code> module as a Maven dependency:</p>

<pre><code>&lt;dependency&gt;
  &lt;groupId&gt;net.kuujo.copycat&lt;/groupId&gt;
  &lt;artifactId&gt;copycat-state-machine&lt;/artifactId&gt;
  &lt;version&gt;0.5.0-SNAPSHOT&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>

<p>The <code>StateMachine</code> interface provides its own constructors similar to the <code>Copycat.create</code> constructors.</p>

<pre><code class="java">StateMachineConfig config = new StateMachineConfig()
  .withStateType(Map.class)
  .withInitialState(DefaultMapState.class)'

StateMachine&lt;Map&lt;K, V&gt;&gt; stateMachine = StateMachine.create("my-state-machine", cluster, config).open().get();
stateMachine.submit("get", "foo").get();
</code></pre>

<h3>Configuring the state machine</h3>

<p>State machines are configured using the <code>StateMachineConfig</code> class. This class contains vital configuration information
regarding how the state machine should handle startup and how it should apply commands.</p>

<p>As demonstrated in the example in the previous section, two vital components of the <code>StateMachineConfig</code> are the
<em>state type</em> and <em>initial state</em>. The state type is an <em>interface</em> which contains all of the state methods. All state
implementations must implement this interface. The initial state is the first state to which the state machine will
transition upon startup.</p>

<pre><code class="java">StateMachineConfig config = new StateMachineConfig()
  .withStateType(Map.class)
  .withInitialState(DefaultMapState.class);
</code></pre>

<p>Alternatively, state machine configurations can be defined via
<a href="https://github.com/typesafehub/config">Typesafe configuration</a> files. Copycat resolves state machine configurations
in the following order:
* <code>StateMachineConfig</code> - the code based state machine configuration can override all other configuration options
* User defined configuration file - the configuration resource specified when constructing a <code>StateMachineConfig</code>,
  e.g. <code>new StateMachineConfig("my-state-machine")</code>
* <code>state-machine</code> configuration resource - a <code>state-machine.conf</code>, <code>state-machine.json</code>, or <code>state-machine.properties</code>
  file on the classpath
* <code>state-machine-defaults.conf</code> - the state machine defaults configuration file
* <code>resource</code> configuration resource - a <code>resource.conf</code>, <code>resource.json</code>, or <code>resource.properties</code> file on the classpath
* <code>resource-defaults.conf</code> - the resource defaults configuration file</p>

<p>Additionally, configurable resources within the state machine configuration - such as the log and serializer - resolve
with a similar hierarchy of precedence.</p>

<p>By default, all Copycat resources use the <code>KryoSerializer</code> for serialization. This should work fine for most use cases,
but if you so desire you can configure the <code>Serializer</code> class on the <code>StateMachineConfig</code>.</p>

<pre><code class="java">StateMachineConfig config = new StateMachineConfig()
  .withStateType(Map.class)
  .withInitialState(DefaultMapState.class)
  .withSerializer(MyCustomSerializer.class);
</code></pre>

<h3>Designing state machine states</h3>

<p>State machines consist of a series of states and transitions between them. Backed by a state log, Copycat guarantees
that commands (state method calls) will be applied to the state machine in the same order on all nodes of a Copycat
cluster. Given the same commands in the same order, state machines should always arrive at the same state with the
same output (return value). That means all commands (methods) of a state machine state <em>must be deterministic</em>; commands
cannot depend on the state of shared external systems such as a database or file system.</p>

<p>State machines are defined by simply defining an interface. While a state machine can consist of many states (state
interface implementations), all states must implement the same interface. This allows Copycat to expose a consistent
interface regardless of the current state of the state machine.</p>

<p>State machine states do not have to extend any particular interface. Simply define the interface itself:</p>

<pre><code class="java">public interface LockState {

  void lock();

  void unlock();

}
</code></pre>

<p>When the state machine is created, the state interface must be provided to the state machine via the
<code>StateMachineConfig</code>. Copycat uses the state interface to expose <a href="#state-machine-commands">commands</a> and
<a href="#state-machine-queries">queries</a> to the state machine client.</p>

<h3>State machine commands</h3>

<p>State machine commands are annotated methods on the state machine state interface. Annotating a method with the
<code>@Command</code> annotation indicates that it is a stateful method call, meaning the operation that calls the method should
be persisted to the log and replicated. It is vital that <em>all</em> methods which alter the state machine's state be
identified by the <code>@Command</code> annotation. For this reason, all state machine methods are commands by default.</p>

<pre><code class="java">public interface MapState&lt;K, V&gt; {

  @Command
  V put(K key);

}
</code></pre>

<h3>State machine queries</h3>

<p>Queries are the counter to commands. The <code>@Query</code> annotation is used to identify state machine methods which are
purely read-only methods. <em>You should never annotate a method that alters the state machine state with the query
annotation.</em> If methods which alter the state machine state are not annotated as commands, calls to the method will
<em>not</em> be logged and replicated, and thus state will be inconsistent across replicas.</p>

<pre><code class="java">public interface MapState&lt;K, V&gt; {

  @Query
  V get(K key);

}
</code></pre>

<p>You can specify the required consistency of queries by defining the <code>@Query</code> annotation's <code>consistency</code> argument.
The query consistency allows you to control how read operations are performed. Copycat supports three consistency
levels:
* <code>WEAK</code> - reads the state machine from the local node. This is the cheapest/fastest consistency level, but will often
  result in stale data being read
* <code>DEFAULT</code> - all reads go through the resource leader which performs consistency checks based on a lease period equal to the
  resource's heartbeat interval
* <code>STRONG</code> - all reads go through the resource leader which performs a synchronous consistency check with a majority of
  the resource's replicas before applying the query to the state machine and returning the result. This is the most
  expensive consistency level.</p>

<p>Query consistency defaults to <code>DEFAULT</code></p>

<pre><code class="java">public interface MapState&lt;K, V&gt; extends Map&lt;K, V&gt; {

  @Override
  @Query(consistency=Consistency.STRONG)
  V get(K key);

}
</code></pre>

<h3>The state context</h3>

<p>Copycat's state machine provides a <code>StateContext</code> object in which state implementations should store state. The reason
for storing state in a separate object rather than in the states themselves is threefold. First, the <code>StateContext</code>
object persists throughout the lifetime of the state machine, even across states. Second, the state machine uses the
state held within the <code>StateContext</code> to take and install snapshots for log compaction. Snapshotting and log compaction
is performed automatically using the context's state; users need only store state in the context in order for snapshots
to work. Third, the state context provides a vehicle through which states can transition to other states.</p>

<p>To get the <code>StateContext</code> object for the state machine, simply add a method to your state annotated with the
<code>@Initializer</code> annotation.</p>

<pre><code class="java">public class DefaultMap&lt;K, V&gt; implements Map&lt;K, V&gt; {
  private StateContext&lt;AsyncMap&lt;K, V&gt;&gt; context;

  @Initializer
  public void init(StateContext&lt;AsyncMap&lt;K, V&gt;&gt; context) {
    this.context = context;
  }

  public V get(K key) {
    return context.&lt;Map&lt;K, V&gt;&gt;get("the-map").get(key);
  }

}
</code></pre>

<h3>Transitioning the state machine state</h3>

<p>To transition to another state via the <code>StateContext</code>, call the <code>transition</code> method. A perfect example of this is
a lock. This example transitions between two states - locked and unlocked - based on the current state.</p>

<pre><code class="java">public class UnlockedLockState implements LockState {
  private StateContext&lt;AsyncMap&lt;K, V&gt;&gt; context;

  @Initializer
  public void init(StateContext&lt;AsyncMap&lt;K, V&gt;&gt; context) {
    this.context = context;
  }

  public void lock() {
    context.transition(new LockedLockState());
  }

  public void unlock() {
    throw new IllegalStateException("Lock is not locked");
  }

}
</code></pre>

<pre><code class="java">public class LockedLockState implements LockState {
  private StateContext&lt;AsyncMap&lt;K, V&gt;&gt; context;

  @Initializer
  public void init(StateContext&lt;AsyncMap&lt;K, V&gt;&gt; context) {
    this.context = context;
  }

  public void lock() {
    throw new IllegalStateException("Lock is locked");
  }

  public void unlock() {
    context.transition(new UnlockedLockState());
  }

}
</code></pre>

<h3>Synchronous proxies</h3>

<p>While Copycat's <code>StateMachine</code> interface exposes a <code>submit</code> method for submitting named commands and queries to the
state machine, it also provides a proxy based interface for operating on the state machine state interface directly.
To create a state machine proxy simply call the <code>createProxy</code> method on the <code>StateMachine</code> object, passing the proxy
interface to implement. The state machine supports both synchronous and asynchronous return values by checking whether
a given proxy interface method's return type is <code>CompletableFuture</code>.</p>

<pre><code class="java">Map&lt;String, String&gt; proxy = stateMachine.createProxy(Map.class);
</code></pre>

<p>Once we've created a state machine proxy, we can simply call methods directly on the proxy object and Copycat will
internally submit <a href="#commands">commands</a> and <a href="#queries">queries</a> to the replicated state machine.</p>

<pre><code class="java">proxy.put("foo", "Hello world!");
System.out.println(proxy.get("foo")); // Hello world!
</code></pre>

<h3>Asynchronous proxies</h3>

<p>The state machine proxy feature also supports asynchronous proxies. It does this simply by checking the return type
of a given proxy method. If the proxy method's return type is <code>CompletableFuture</code> then the method will be executed
in a separate thread.</p>

<p>Often times asynchronous proxies require creating a separate proxy interface.</p>

<pre><code class="java">public interface AsyncMap&lt;K, V&gt; {

  CompletableFuture&lt;V&gt; put(K key, V value);

  CompletableFuture&lt;V&gt; get(K key);

  CompletableFuture&lt;V&gt; remove(K key);

  CompletableFuture&lt;Void&gt; clear();

}
</code></pre>

<p>Aside from the return types, asynchronous proxies work the same way as synchronous proxies. To create an asynchronous
proxy simply call the <code>createProxy</code> method, passing the asynchronous proxy interface.</p>

<pre><code class="java">AsyncMap&lt;K, V&gt; map = stateMachine.createProxy(AsyncMap.class);

map.put("foo", "Hello world!").thenRun(() -&gt; {
  map.get("foo").thenAccept(value -&gt; System.out.println(value)); // Hello world!
});
</code></pre>

<h2>Event logs</h2>

<p>Event logs are eventually consistent Raft replicated logs that are designed to be compacted based on time or size.</p>

<h3>Creating an event log</h3>

<p>To create an event log, call the <code>createEventLog</code> method on the <code>Copycat</code> instance.</p>

<pre><code class="java">ClusterConfig cluster = new ClusterConfig()
  .withProtocol(new NettyTcpProtocol())
  .withLocalMember("tcp://123.456.789.0:5000")
  .withMembers("tcp://123.456.789.0", "tcp://123.456.789.1", "tcp://123.456.789.2");

CopycatConfig config = new CopycatConfig()
  .withClusterConfig(cluster)
  .addEventLogConfig("event-log", new EventLogConfig());

Copycat copycat = Copycat.create(config);

copycat.open().thenRun(() -&gt; {
  copycat.&lt;String&gt;createEventLog("event-log").open().thenAccept(eventLog -&gt; {
    eventLog.commit("Hello world!");
  });
});
</code></pre>

<p>Alternatively, an event log can be created independent of the high-level <code>Copycat</code> API by simply adding the
<code>copycat-event-log</code> module as a dependency directly:</p>

<pre><code>&lt;dependency&gt;
  &lt;groupId&gt;net.kuujo.copycat&lt;/groupId&gt;
  &lt;artifactId&gt;copycat-event-log&lt;/artifactId&gt;
  &lt;version&gt;0.5.0-SNAPSHOT&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>

<p>The <code>EventLog</code> interface exposes a static method for creating a standalone event log:</p>

<pre><code class="java">ClusterConfig cluster = new ClusterConfig()
  .withProtocol(new NettyTcpProtocol())
  .withLocalMember("tcp:/123.456.789.0:5000")
  .withMembers("tcp://123.456.789.0:5000", "tcp://123.456.789.1:5000", "tcp://123.456.789.2:5000");

EventLogConfig config = new EventLogConfig()
  .withLog(new FileLog());

EventLog&lt;String&gt; eventLog = EventLog.create("my-event-log", cluster, config);
</code></pre>

<p>When a standalone event log is created via the <code>EventLog.create</code> static factory method, a <code>ClusterCoordinator</code> is
created and will be automatically shut down once <code>close</code> is called on the created <code>EventLog</code>.</p>

<h3>Event log configuration</h3>

<p>Event logs are designed to maintain long histories of events. Copycat provides a number of configuration options for
the file logs underlying event log resources which allow users to configure both the size of the event log and the
time for which event log segments are retained.</p>

<p>The three most notable <code>Log</code> configuration options for event logs are the segment size, the flush interval, and
retention policies.</p>

<p>All Copycat logs are broken into segments internally. In order for a segment of the log to be freed (deleted from disk),
the segment must not be the last segment in the log. This means if segments were configured with the size
<code>Long.MAX_VALUE</code> then Copycat would never clean the log. The segment size and interval can be configured by using the
<code>withSegmentSize</code> and <code>withSegmentInterval</code> methods of the <code>Log</code> interface respectively:</p>

<pre><code class="java">Log log = new FileLog()
  .withSegmentSize(1024 * 1024)
  .withSegmentInterval(60, TimeUnit.MINUTES);
</code></pre>

<p>The segment size dictates the maximum size of any given segment, and the interval indicates that maximum amount of
time a segment can exist before the log is rolled over to a new segment.</p>

<p>Users can also configure the interval at which Copycat flushes logs to disk. For event logs, typically the flush
interval does not need to be configured, allowing the <code>FileChannel</code> implementation to handle flushing to disk
internally. However, to configure the event log's flush interval use the <code>withFlushInterval</code> method:</p>

<pre><code class="java">Log log = new FileLog()
  .withFlushInterval(60, TimeUnit.SECONDS);
</code></pre>

<p>Alternatively, event log configurations can be defined by
<a href="https://github.com/typesafehub/config">Typesafe configuration</a> files. Copycat resolves event log configurations
in the following order:
* <code>EventLogConfig</code> - the code based event log configuration can override all other configuration options
* User defined configuration file - the configuration resource specified when constructing a <code>EventLogConfig</code>,
  e.g. <code>new EventLogConfig("my-event-log")</code>
* <code>event-log</code> configuration resource - a <code>event-log.conf</code>, <code>event-log.json</code>, or <code>event-log.properties</code>
  file on the classpath
* <code>event-log-defaults.conf</code> - the event log defaults configuration file
* <code>resource</code> configuration resource - a <code>resource.conf</code>, <code>resource.json</code>, or <code>resource.properties</code> file on the classpath
* <code>resource-defaults.conf</code> - the resource defaults configuration file</p>

<p>To construct an event log configuration from a custom configuration file, simply specify the configuration resource
name in the <code>EventLogConfig</code> constructor:</p>

<pre><code class="java">EventLogConfig config = new EventLogConfig("my-event-log");
</code></pre>

<p>Finally, event logs support configurable retention policies. Retention policies dictate the amount of
time for which a <em>segment</em> of the log is held on disk. For instance, the <code>FullRetentionPolicy</code> keeps logs forever,
while the <code>TimeBasedRetentionPolicy</code> allows segments of the log to be deleted after a certain amount of time has passed
since the segment was created.</p>

<pre><code class="java">EventLogConfig config = new EventLogConfig()
  .withLog(new FileLog().withSegmentSize(1024 * 1024 * 32))
  .withRetentionPolicy(new SizeBasedRetentionPolicy(1024 * 1024 * 128));
</code></pre>

<p>Copycat provides the following log retention policies:
* <code>FullRetentionPolicy</code> - keeps all log segments forever
* <code>ZeroRetentionPolicy</code> - deletes segments immediately after the log has been rotated
* <code>TimeBasedRetentionPolicy</code> - deletes segments after a period of time has passed since they were <em>created</em>
* <code>SizeBasedRetentionPolicy</code> - deletes segments once the complete log grows to a certain size</p>

<p>Note that additional logs such as the <code>ChronicleLog</code> may provide additional configuration options related to their
specific implementation.</p>

<h3>Writing events to the event log</h3>

<p>To write events to an event log, simply call the <code>commit(T entry)</code> method:</p>

<pre><code class="java">eventLog.commit("Hello world!");
</code></pre>

<p>The <code>CompletableFuture</code> returned by the <code>commit</code> method will be completed once the entry has been logged and replicated
to a majority of the resource's replica set.</p>

<h3>Consuming events from the event log</h3>

<p>To consume messages from the event log, register a message consumer via the <code>consumer</code> method:</p>

<pre><code class="java">eventLog.consumer(entry -&gt; System.out.println(entry));
</code></pre>

<h2>State logs</h2>

<p>State logs are strongly consistent Raft replicated logs designed for persisting state. These logs are the basis of
Copycat's state machine and the data structures built on top of it. Whereas event logs are designed for time/size based
compaction, state logs support log compaction via snapshotting, allowing state to be persisted to the log and
replicated to other nodes in the cluster whenever necessary.</p>

<h3>Creating a state log</h3>

<p>To create a state log, call the <code>stateLog</code> method on the <code>Copycat</code> instance.</p>

<pre><code class="java">ClusterConfig cluster = new ClusterConfig()
  .withProtocol(new NettyTcpProtocol())
  .withLocalMember("tcp://123.456.789.0:5000")
  .withMembers("tcp://123.456.789.0:5000", "tcp://123.456.789.1:5000", "tcp://123.456.789.2:5000");

CopycatConfig config = new CopycatConfig()
  .withClusterConfig(cluster)
  .addStateLogConfig("state-log", new StateLogConfig()
    .withLog(new FileLog());

Copycat copycat = Copycat.create(config);

copycat.open().thenRun(() -&gt; {
  copycat.&lt;String&gt;createStateLog("state-log").open().thenAccept(stateLog -&gt; {
    stateLog.commit("Hello world!");
  });
});
</code></pre>

<p>The <code>StateLog</code> interface exposes a static method for creating a standalone state log:</p>

<pre><code class="java">ClusterConfig cluster = new ClusterConfig()
  .withProtocol(new NettyTcpProtocol())
  .withLocalMember("tcp:/123.456.789.0:5000")
  .withMembers("tcp://123.456.789.0:5000", "tcp://123.456.789.1:5000", "tcp://123.456.789.2:5000");

StateLogConfig config = new StateLogConfig()
  .withLog(new FileLog()
    .withFlushOnWrite(true));

StateLog&lt;String&gt; stateLog = StateLog.create("my-state-log", cluster, config);
</code></pre>

<p>When a standalone state log is created via the <code>StateLog.create</code> static factory method, a <code>ClusterCoordinator</code> is
created and will be automatically shut down once <code>close</code> is called on the created <code>StateLog</code>.</p>

<p>The generic type - <code>T</code> - is the log entry type.</p>

<h3>State log configuration</h3>

<p>Since state logs are designed to assist in managing state - including for Copycat's state machines and data structures -
it is strongly recommended that the state logs use persistent logs such as the <code>FileLog</code> and configure the log to
frequently flush the log to disk.</p>

<pre><code class="java">StateLogConfig config = new StateLogConfig()
  .withFileLog(new FileLog()
    .withFlushOnWrite(true)
    .withSegmentSize(1024 * 1024 * 32));
</code></pre>

<p>The state log implementation uses the segment size to determine when to take snapshots. Once the log grows beyond a
single segment, the state log will take a snapshot and remove all but the first segment in the log. In order to prevent
performance issues from snapshotting too frequently, segments should not be made too small.</p>

<p>Alternatively, state log configurations can be defined by
<a href="https://github.com/typesafehub/config">Typesafe configuration</a> files. Copycat resolves state log configurations
in the following order:
* <code>StateLogConfig</code> - the code based state log configuration can override all other configuration options
* User defined configuration file - the configuration resource specified when constructing a <code>StateLogConfig</code>,
  e.g. <code>new StateLogConfig("my-state-log")</code>
* <code>state-log</code> configuration resource - a <code>state-log.conf</code>, <code>state-log.json</code>, or <code>state-log.properties</code>
  file on the classpath
* <code>state-log-defaults.conf</code> - the state log defaults configuration file
* <code>resource</code> configuration resource - a <code>resource.conf</code>, <code>resource.json</code>, or <code>resource.properties</code> file on the classpath
* <code>resource-defaults.conf</code> - the resource defaults configuration file</p>

<p>To construct an event log configuration from a custom configuration file, simply specify the configuration resource
name in the <code>EventLogConfig</code> constructor:</p>

<pre><code class="java">EventLogConfig config = new EventLogConfig("my-event-log");
</code></pre>

<h3>State commands</h3>

<p>State logs work to alter state by applying log entries to registered state commands. Commands are operations which
alter the state machine state. When submitted to the state log, all commands (writes) go through the resource leader
and are logged and replicated prior to being applied to the command function.</p>

<p>To register a state command, use the <code>registerCommand</code> method.</p>

<pre><code class="java">stateLog.registerCommand("add", entry -&gt; data.add(entry));
</code></pre>

<h3>State queries</h3>

<p>As you can see above state logs separate <em>read</em> operations from <em>write</em> operations, and for good reason. Write
operations require strong consistency and persistence, while read operations - which don't alter the state of the log -
can be performed without persistence. To register a read operation on the state log, use the <code>registerQuery</code> method:</p>

<pre><code class="java">stateLog.registerQuery("get", index -&gt; data.get(index));
</code></pre>

<p>Because of the flexibility of read-only operations, Copycat provides several consistency modes with which users can
trade consistency for performance and vice versa.
* <code>STRONG</code> - Guarantees strong consistency of all reads by performing reads through the leader which contacts a majority
  of nodes to verify the cluster state prior to responding to the request
* <code>DEFAULT</code> - Promotes consistency using a leader lease with which the leader assumes consistency for a period of time
  before contacting a majority of the cluster in order to check consistency
* <code>WEAK</code> - Allows stale reads from the local node</p>

<p>To specify the query consistency, simply pass an additional <code>Consistency</code> parameter to <code>registerQuery</code>:</p>

<pre><code class="java">stateLog.registerQuery("get", index -&gt; data.get(index), Consistency.FULL);
</code></pre>

<h3>Submitting operations to the state log</h3>

<p>Once <a href="#state-commands">commands</a> and <a href="#state-queries">queries</a> have been registered on the log, commands and queries
can be submitted to the log. To submit a named operation to the log, call the <code>submit</code> method.</p>

<pre><code class="java">stateLog.submit("add", "Hello world!");
</code></pre>

<p>The <code>CompletableFuture</code> returned by the <code>submit</code> method will be completed once the entry has been logged and replicated
on a majority of the resource's <a href="#active-members">active member</a> replicas.</p>

<h3>Snapshotting</h3>

<p>Up until this point, if the state log were allowed to run unencumbered for a long enough period of time, presumably
your machines would run out of disk space for the log. Fortunately, the Raft algorithm has a mechanism for compacting
the state log: snapshots. By registering a snapshot handler on the state log, Copycat will periodically call the handler
and replace a portion of the log with the state returned by the snapshot provider. Then, in the event of a failure the
snapshot installer will be called to repopulate the state from the last snapshot.</p>

<p>To register a snapshot provider on the state log, use the <code>snapshotWith</code> methods:</p>

<pre><code class="java">stateLog.snapshotWith(() -&gt; data);
</code></pre>

<p>Any snapshot provider should be accompanied by a snapshot installer as well.</p>

<pre><code class="java">stateLog.installWith(data -&gt; {
  this.data = data;
});
</code></pre>

<p>Don't worry, Copycat will handle all the complexity of persisting, loading, and replicating snapshots. If you want to
see what can be built on top of the Copycat state log, see Copycat's replicated <a href="#state-machine">state machine</a>
implementation.</p>

<h2>Leader elections</h2>

<p>Leader elections are perhaps the simplest feature of Copycat, but often one of the most useful as well. One of the more
significant challenges faced by many distributed systems is coordinating leadership among a set of nodes. Copycat's
simple Raft based leader election implementation allows users to elect a leader within a resource cluster and then
use Copycat's messaging and remote execution features to react on that leader election.</p>

<p>Note that the leader election resource type simply wraps the resource <code>Cluster</code> based <code>LeaderElection</code> API. In reality,
all Copycat resources participate in elections, and resource elections can be accessed via each respective resource's
<code>Cluster</code>.</p>

<h3>Creating a leader election</h3>

<p>To create a <code>LeaderElection</code> via the <code>Copycat</code> API, add the <code>LeaderElectionConfig</code> to your <code>CopycatConfig</code>.</p>

<pre><code class="java">CopycatConfig config = new CopycatConfig()
  .withClusterConfig(cluster)
  .addElectionConfig("election", new LeaderElectionConfig());
</code></pre>

<p>By default, leader elections use an in-memory log - <code>BufferedLog</code>. Since leader elections only use a lightweight
implementation of the Raft election algorithm to elect leaders, persistent logs are unnecessary for most use cases.</p>

<p>Once the leader election has been defined as a cluster resource, create a new <code>Copycat</code> instance and get the leader
election. To register a handler to be notified once a node has become leader, use the <code>addListener</code> method.</p>

<pre><code class="java">Copycat copycat = Copycat.create(config);

copycat.open()
  .thenCompose(c -&gt; c.createLeaderElection("election").open())
  .thenAccept(election -&gt; {
    election.addListener(member -&gt; System.out.println(member.uri() + " was elected leader!");
  });
</code></pre>

<p>Alternatively, users can use the <code>LeaderElection</code> API as a standalone service by adding the <code>copycat-leader-election</code>
module as a direct dependency:</p>

<pre><code>&lt;dependency&gt;
  &lt;groupId&gt;net.kuujo.copycat&lt;/groupId&gt;
  &lt;artifactId&gt;copycat-leader-election&lt;/artifactId&gt;
  &lt;version&gt;0.5.0-SNAPSHOT&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>

<p>The <code>LeaderElection</code> interface exposes a static factory method for creating standalone leader election instances:</p>

<pre><code class="java">ClusterConfig cluster = new ClusterConfig()
  .withLocalMember("tcp://123.456.789.0:5000")
  .withMembers("tcp://123.456.789.0:5000", "tcp://123.456.789.1:5000", "tcp://123.456.789.2:5000");

LeaderElection.create("election", cluster).open().thenAccept(election -&gt; {
  election.addListener(member -&gt; {
    System.out.println(member.uri() + " was elected leader!");
  });
});
</code></pre>

<h2>Collections</h2>

<p>In a partially academic effort, Copycat provides a variety of strongly consistent distributed data structures built on
top of its <a href="#state-machines">state machine</a> framework.
* <a href="#asyncmap">AsyncMap</a>
* <a href="#asynclist">AsyncList</a>
* <a href="#asyncset">AsyncSet</a>
* <a href="#asyncmultimap">AsyncMultiMap</a></p>

<p>Each collection provides options for configuring the consistency of read operations. To configure the consistency,
use the <code>setConsistency</code> method or <code>withConsistency</code> fluent method on the respective data structure configuration:</p>

<pre><code class="java">AsyncMapConfig config = new AsyncMapConfig()
  .withConsistency(Consistency.STRONG);
</code></pre>

<p>Collections can either be created via the high-level <code>Copycat</code> API or through the respective collection constructors
themselves. Each collection interface exposes a static <code>create</code> factory method which creates a standalone instance of
the distributed collection.</p>

<p>To access collection factory methods directly add the <code>copycat-collections</code> module as a direct dependency:</p>

<pre><code>&lt;dependency&gt;
  &lt;groupId&gt;net.kuujo.copycat&lt;/groupId&gt;
  &lt;artifactId&gt;copycat-collections&lt;/artifactId&gt;
  &lt;version&gt;0.5.0-SNAPSHOT&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>

<p>To create a collection, call the static <code>create</code> factory method on the collection's interface, passing the collection
name, cluster configuration, and optional collection configuration.</p>

<pre><code class="java">AsyncList.&lt;String&gt;create("my-list", cluster).open().thenAccept(list -&gt; {
  list.add("Hello world!");
});
</code></pre>

<h3>AsyncMap</h3>

<p>Copycat's map implementation uses a simple <a href="#state-machines">state machine</a> to provide access to a consistent
distributed map via state machine <a href="#synchronous-proxies">proxies</a>.</p>

<p>To create a map via the <code>Copycat</code> API, use the <code>map</code> method:</p>

<pre><code class="java">ClusterConfig cluster = new ClusterConfig()
  .withProtocol(new NettyTcpProtocol())
  .withLocalMember("tcp://123.456.789.0:5000")
  .withMembers("tcp://123.456.789.0:5000", "tcp://123.456.789.1:5000", "tcp://123.456.789.2:5000");

CopycatConfig config = new CopycatConfig()
  .withClusterConfig(cluster)
  .addMapConfig("test-map", new AsyncMapConfig()
    .withConsistency(Consistency.STRONG));

Copycat.copycat(config).open()
  .thenApply(copycat -&gt; copycat.&lt;String, String&gt;createMap("test-map"))
  .thenCompose(map -&gt; map.open())
  .thenAccept(map -&gt; {
    map.put("foo", "Hello world!").thenRun(() -&gt; {
      map.get("foo").thenAccept(result -&gt; System.out.println(result));
    });
  });
</code></pre>

<p>To create a map directly, use the <code>AsyncMap.create</code> factory method:</p>

<pre><code class="java">ClusterConfig cluster = new ClusterConfig()
  .withProtocol(new NettyTcpProtocol())
  .withLocalMember("tcp://123.456.789.0:5000")
  .withMembers("tcp://123.456.789.0:5000", "tcp://123.456.789.1:5000", "tcp://123.456.789.2:5000");

AsyncMapConfig config = new AsyncMapConfig()
  .withConsistency(Consistency.STRONG);

AsyncMap.&lt;String, String&gt;create("my-map", cluster, config).open().thenAccept(map -&gt; {
  map.put("foo", "Hello world!").thenRun(() -&gt; {
    map.get("foo").thenAccept(result -&gt; System.out.println(result));
  });
});
</code></pre>

<h3>AsyncList</h3>

<p>Copycat's list implementation uses a simple <a href="#state-machines">state machine</a> to provide access to a consistent
distributed list via state machine <a href="#synchronous-proxies">proxies</a>.</p>

<p>To create a list via the <code>Copycat</code> API, use the <code>list</code> method:</p>

<pre><code class="java">ClusterConfig cluster = new ClusterConfig()
  .withProtocol(new NettyTcpProtocol())
  .withLocalMember("tcp://123.456.789.0:5000")
  .withMembers("tcp://123.456.789.0:5000", "tcp://123.456.789.1:5000", "tcp://123.456.789.2:5000");

CopycatConfig config = new CopycatConfig()
  .withClusterConfig(cluster)
  .addListConfig("test-list", new AsyncListConfig()
    .withConsistency(Consistency.STRONG));

Copycat.copycat(config).open()
  .thenApply(copycat -&gt; copycat.&lt;String&gt;createList("test-list"))
  .thenCompose(list -&gt; list.open())
  .thenAccept(list -&gt; {
    list.add("Hello world!").thenRun(() -&gt; {
      list.get(0).thenAccept(result -&gt; System.out.println(result));
    });
  });
</code></pre>

<p>To create a list directly, use the <code>AsyncList.create</code> factory method:</p>

<pre><code class="java">ClusterConfig cluster = new ClusterConfig()
  .withProtocol(new NettyTcpProtocol())
  .withLocalMember("tcp://123.456.789.0:5000")
  .withMembers("tcp://123.456.789.0:5000", "tcp://123.456.789.1:5000", "tcp://123.456.789.2:5000");

AsyncListConfig config = new AsyncListConfig()
  .withConsistency(Consistency.STRONG);

AsyncList.&lt;String&gt;create("my-list", cluster, config).open().thenAccept(list -&gt; {
  list.add("Hello world!").thenRun(() -&gt; {
    list.get(0).thenAccept(result -&gt; System.out.println(result));
  });
});
</code></pre>

<h3>AsyncSet</h3>

<p>Copycat's set implementation uses a simple <a href="#state-machines">state machine</a> to provide access to a consistent
distributed set via state machine <a href="#synchronous-proxies">proxies</a>.</p>

<p>To create a set via the <code>Copycat</code> API, use the <code>set</code> method:</p>

<pre><code class="java">ClusterConfig cluster = new ClusterConfig()
  .withProtocol(new NettyTcpProtocol())
  .withLocalMember("tcp://123.456.789.0:5000")
  .withMembers("tcp://123.456.789.0:5000", "tcp://123.456.789.1:5000", "tcp://123.456.789.2:5000");

CopycatConfig config = new CopycatConfig()
  .withClusterConfig(cluster)
  .addSetConfig("test-set", new AsyncSetConfig()
    .withConsistency(Consistency.STRONG));

Copycat.copycat(config).open()
  .thenApply(copycat -&gt; copycat.&lt;String&gt;createSet("test-set"))
  .thenCompose(set -&gt; set.open())
  .thenAccept(set -&gt; {
    set.add("Hello world!").thenRun(() -&gt; {
      set.get(0).thenAccept(result -&gt; System.out.println(result));
    });
  });
</code></pre>

<p>To create a set directly, use the <code>AsyncSet.create</code> factory method:</p>

<pre><code class="java">ClusterConfig cluster = new ClusterConfig()
  .withProtocol(new NettyTcpProtocol())
  .withLocalMember("tcp://123.456.789.0:5000")
  .withMembers("tcp://123.456.789.0:5000", "tcp://123.456.789.1:5000", "tcp://123.456.789.2:5000");

AsyncSetConfig config = new AsyncSetConfig()
  .withConsistency(Consistency.STRONG);

AsyncSet.&lt;String&gt;create("my-set", cluster, config).open().thenAccept(set -&gt; {
  set.add("Hello world!").thenRun(() -&gt; {
    set.get(0).thenAccept(result -&gt; System.out.println(result));
  });
});
</code></pre>

<h3>AsyncMultiMap</h3>

<p>Copycat's multimap implementation uses a simple <a href="#state-machines">state machine</a> to provide access to a consistent
distributed multimap via state machine <a href="#synchronous-proxies">proxies</a>.</p>

<p>To create a multimap via the <code>Copycat</code> API, use the <code>multiMap</code> method:</p>

<pre><code class="java">ClusterConfig cluster = new ClusterConfig()
  .withProtocol(new NettyTcpProtocol())
  .withLocalMember("tcp://123.456.789.0:5000")
  .withMembers("tcp://123.456.789.0:5000", "tcp://123.456.789.1:5000", "tcp://123.456.789.2:5000");

CopycatConfig config = new CopycatConfig()
  .withClusterConfig(cluster)
  .addMultiMapConfig("test-multimap", new AsyncMultiMapConfig()
    .withConsistency(Consistency.STRONG));

Copycat.copycat(config).open()
  .thenApply(copycat -&gt; copycat.&lt;String, String&gt;createMultiMap("test-multimap"))
  .thenCompose(multiMap -&gt; multiMap.open())
  .thenAccept(multiMap -&gt; {
    multiMap.put("foo", "Hello world!").thenRun(() -&gt; {
      multiMap.get("foo").thenAccept(result -&gt; System.out.println(result));
    });
  });
</code></pre>

<p>To create a multimap directly, use the <code>AsyncMultiMap.create</code> factory method:</p>

<pre><code class="java">ClusterConfig cluster = new ClusterConfig()
  .withProtocol(new NettyTcpProtocol())
  .withLocalMember("tcp://123.456.789.0:5000")
  .withMembers("tcp://123.456.789.0:5000", "tcp://123.456.789.1:5000", "tcp://123.456.789.2:5000");

AsyncMultiMapConfig config = new AsyncMultiMapConfig()
  .withConsistency(Consistency.STRONG);

AsyncMultiMap.&lt;String, String&gt;create("my-map", cluster, config).open().thenAccept(multiMap -&gt; {
  multiMap.put("foo", "Hello world!").thenRun(() -&gt; {
    multiMap.get("foo").thenAccept(result -&gt; System.out.println(result));
  });
});
</code></pre>

<h2>The Copycat cluster</h2>

<p>The Copycat cluster is designed not only to support leader election and replication for Copycat and its resources, but
it also serves as a general messaging utility for users as well. At the center of Copycat's cluster is the
<em>cluster coordinator</em>. The coordinator is responsible for managing communication and resources throughout the cluster.
Each <code>Copycat</code> or standalone log instance contains a single <code>ClusterCoordinator</code> through which all resources
communicate. Resource clusters wrap the central cluster coordinator to provide resource-specific leader election and
messaging. This allows Copycat to support multiple contexts within the same cluster.</p>

<h3>Members</h3>

<p>The Copycat cluster consists of two different types of members, <a href="#active">active</a> and <a href="#passive">passive</a>. Copycat's
resource behavior differs on each member of the cluster according to the member type. Additionally, each Copycat
instance maintains several versions of the cluster configuration - one global version and a cluster for each
resource. This allows for a flexible replication model where different resources within the same Copycat cluster
operate completely independently from each other in terms of leader election and log replication.</p>

<h3>Active members</h3>

<p>The core of the Copycat cluster consists of a set of <em>active members</em>. Active members are required, permanent, voting
members of the Copycat cluster. Active members are defined for each Copycat instance prior to startup:</p>

<pre><code class="java">ClusterConfig cluster = new ClusterConfig()
  .withProtocol(new NettyTcpProtocol())
  .withLocalMember("tcp://123.456.789.0:5000")
  .withMembers("tcp://123.456.789.0:5000", "tcp://123.456.789.1:5000", "tcp://123.456.789.2:5000");

CopycatConfig config = new CopycatConfig()
  .withClusterConfig(cluster)
  .addResourceConfig(...);

Copycat copycat = Copycat.create(config);
</code></pre>

<p>By creating a Copycat instance with a local URI that is defined as an active member in the cluster configuration, Copycat
knows that this is an active member of the cluster:</p>

<pre><code class="java">assert copycat.cluster().member().type() == Member.Type.ACTIVE;
</code></pre>

<p>It is important that <em>all members of the Copycat cluster contain identical cluster configurations</em>. Note that this
cluster configuration identifies <em>only</em> the core active members of the Copycat cluster, and each cluster configuration
must specify at least one active cluster member. Members that are not represented in the cluster configuration are
known as <a href="#passive-members">passive members</a>.</p>

<p>Active members are distinguished from passive members in that they fully participate in log replication via the
<a href="https://raftconsensus.github.io/">Raft consensus protocol</a>. This means that only active cluster members can become
leaders, and only active members can serve as synchronous replicas to cluster resources.</p>

<p>Since each Copycat resource contains its own separate <code>Cluster</code>, Copycat allows the resource's active membership to
differ from the global Copycat cluster membership. This means that even though the Copycat cluster may consist of five
total nodes with three active member nodes, a resource can perform synchronous replication on only three of those nodes.
In that case, the resource's Raft algorithm would run on those three nodes, and an asynchronous gossip protocol would
perform replication to the remainder of the resource's cluster.</p>

<h3>Passive members</h3>

<p>Passive members are members of the Copycat cluster that do not participate in synchronous replication via the Raft
consensus protocol. Instead, Copycat uses a simple gossip protocol to asynchronously replicate committed log entries
to passive members of the cluster.</p>

<p>Members are defined as nodes which are not represented in the Copycat cluster configuration. Thus, starting a <code>Copycat</code>
instance or any resource with a local member URI that is not contained within the provided <code>ClusterConfig</code> indicates
that the member is passive and should thus receive replicated logs passively:</p>

<pre><code class="java">ClusterConfig cluster = new ClusterConfig()
  .withProtocol(new NettyTcpProtocol())
  .withLocalMember("tcp://123.456.789.4:5000")
  .withMembers("tcp://123.456.789.0:5000", "tcp://123.456.789.1:5000", "tcp://123.456.789.2:5000");

CopycatConfig config = new CopycatConfig()
  .withClusterConfig(cluster)
  .addResourceConfig(...);

Copycat copycat = Copycat.create(config);
</code></pre>

<p>By simply defining a local URI that is not defined as an active member of the Copycat cluster, the Copycat instance
becomes a passive member of the cluster:</p>

<pre><code class="java">assert copycat.cluster().member().type() == Member.Type.PASSIVE;
</code></pre>

<p>See below for more information on
<a href="#eventual-consistency-and-copycats-gossip-protocol">eventual consistency and Copycat's gossip protocol</a>.</p>

<h3>Member states</h3>

<p>Throughout the lifecycle of a Copycat cluster, passive members can join and leave the cluster at will. In the case of
passive members, Copycat does not distinguish between a member leaving the cluster and a member crashing. From the
perspective of any given member in the cluster, each other member of the cluster can be in one of three states at any
given time. These three states are defined by the <code>Member.State</code> enum:
* <code>ALIVE</code> - The member is alive and available for messaging and replication
* <code>SUSPICIOUS</code> - The member is unreachable and may have crashed or left the cluster voluntarily
* <code>DEAD</code> - The member is no longer part of the cluster</p>

<p>Just as cluster membership can differ across resources, so too can individual member states. Each member within a
resource cluster is guaranteed to also be present in the global Copycat cluster, but members in the Copycat cluster
may not be present in each resource cluster. This is because some passive members of the Copycat cluster may not have
opened all resources, and some resources may simply not be assigned to some active members of the cluster. Only once a
resource is opened on a passive member of the cluster will it join the resource's cluster and participate in
asynchronous replication via the <a href="#eventual-consistency-and-copycats-gossip-protocol">gossip protocol</a>.</p>

<h3>Leader election</h3>

<p>Leader election within the Copycat cluster is performed on a global and per-resource basis. Each Copycat cluster -
including the global cluster and per-resource clusters - maintains separate leader election state. Copycat provides
a simple API for listening for election events throughout the Copycat cluster.</p>

<p>To register an election listener for the entire Copycat cluster, use the <code>Copycat</code> instance's <code>Cluster</code>:</p>

<pre><code class="java">copycat.cluster().election().addListener(result -&gt; {
  System.out.println(result.winner() + " elected leader!");
});
</code></pre>

<p>Additionally, each resource contains the same method for accessing the resource specific cluster's election:</p>

<pre><code class="java">copycat.stateMachine("my-state-machine").open().thenAccept(stateMachine -&gt; {
  stateMachine.cluster().election().addListener(result -&gt; {
    System.out.println(result.winner() + " elected leader!");
  });
});
</code></pre>

<h3>Direct messaging</h3>

<p>Copycat uses a simple messaging framework to communicate between nodes in order to perform coordination, leader election,
and replication, and that framework is exposed to the user for each resource as well. Copycat's messaging framework
uses topics to route messages to specific message handlers on any given node.</p>

<p>To register a handler to receive messages for a topic, call the <code>registerHandler</code> method on the <code>LocalMember</code> instance.</p>

<pre><code class="java">copycat.stateMachine("my-state-machine").open().thenAccept(stateMachine -&gt; {
  stateMachine.cluster().member().registerHandler(message -&gt; {
    return CompletableFuture.completedFuture("world!");
  });
});
</code></pre>

<p>Cluster message handlers must return a <code>CompletableFuture</code>. If the message is handled synchronously, simply return
an immediately completed future as demonstrated above. Otherwise, asynchronous calls to Copycat resources can be made
within the message handler without blocking the Copycat event loop.</p>

<p>To send a message to another member in the cluster, call the <code>send</code> method on any <code>Member</code> instance.</p>

<pre><code class="java">copycat.stateMachine("my-state-machine").open().thenAccept(stateMachine -&gt; {
  stateMachine.cluster().members().forEach(member -&gt; {
    member.send("Hello").thenAccept(reply -&gt; {
      System.out.println("Hello " + reply); // Hello world!
    });
  });
});
</code></pre>

<h3>Broadcast messaging</h3>

<p>Copycat also allows the exposed <code>Cluster</code> to be used to broadcast messages to all members of the cluster. Note that
Copycat's broadcast functionality is <em>not</em> guaranteed, and Copycat makes no promises about either the order in which
messages will be delivered or even whether they'll be delivered at all.</p>

<p>Cluster-wide broadcast messages work similarly to direct messages in that they are topic based. To register a broadcast
message listener call <code>addBroadcastListener</code> on any <code>Cluster</code> instance:</p>

<pre><code class="java">copycat.cluster().addBroadcastListener(message -&gt; {
  System.out.println("Got message " + message);
});
</code></pre>

<p>To broadcast a message to all members of a cluster use the <code>broadcast</code> method on the <code>Cluster</code> instance:</p>

<pre><code class="java">copycat.cluster().broadcast("Hello world!");
</code></pre>

<p>Note that broadcasts apply <em>only to the membership for the cluster on which the message was broadcast</em>. In other words,
broadcast messages will only be sent to <code>ALIVE</code> members of the cluster through which the message was sent. If you want
to broadcast a message to <em>all</em> of the members of the Copycat cluster, use the global <code>Cluster</code> which can be retrieved
through the <code>Copycat</code> instance.</p>

<h3>Remote execution</h3>

<p>In addition to sending messages to other members of the cluster, Copycat also supports execution of arbitrary tasks on
remote nodes. For example, this is particularly useful for executing code on a resource's leader node once a leader has
been elected.</p>

<pre><code class="java">Task&lt;String&gt; sayHello = () -&gt; "Hello world!";

copycat.stateMachine("my-state-machine").open().thenAccept(stateMachine -&gt; {
  stateMachine.cluster().election().addListener(result -&gt; {
    result.winner().submit(sayHello).thenAccept(result -&gt; {
      System.out.println(result); // Hello world!
    });
  });
});
</code></pre>

<h2>Protocols</h2>

<p>Copycat's communication system provides a pluggable framework that allows the underlying message transport to be
configured based on the environment in which Copycat is deployed. Copycat uses the cluster protocol to perform all
messaging around the cluster, including for leader elections, replication, and other communication. <em>It is essential
that all members of the cluster configure the same protocol</em>, otherwise communication will fail and the cluster will
be deadlocked. Copycat provides a number of existing protocol implementations for various asynchronous frameworks.</p>

<h3>The local protocol</h3>

<p>The local protocol is a special protocol that is implemented purely for testing purposes. It supports passing messages
across threads via a <code>ConcurrentHashMap</code> member registry.</p>

<p>The local protocol is part of <code>copycat-core</code> and thus can be simply added to any <code>ClusterConfig</code> within the need for
dependencies:</p>

<pre><code class="java">ClusterConfig cluster = new ClusterConfig()
  .withProtocol(new LocalProtocol());
</code></pre>

<h3>Netty protocol</h3>

<p>The Netty protocol is a fast <a href="http://netty.io">Netty</a> based TCP protocol. To add the Netty protocol to your Maven
project, add the <code>copycat-netty</code> module to your <code>pom.xml</code>:</p>

<pre><code>&lt;dependency&gt;
  &lt;groupId&gt;net.kuujo.copycat&lt;/groupId&gt;
  &lt;artifactId&gt;copycat-netty&lt;/artifactId&gt;
  &lt;version&gt;0.5.0-SNAPSHOT&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>

<p>Then add the netty TCP protocol to your Copycat cluster configuration:</p>

<pre><code class="java">ClusterConfig cluster = new ClusterConfig()
  .withProtocol(new NettyTcpProtocol());
</code></pre>

<h3>Vert.x protocol</h3>

<p>The Vert.x protocol module provides several protocol implementations for <a href="http://vertx.io">Vert.x 2</a>, including:
* <code>VertxEventBusProtocol</code>
* <code>VertxTcpProtocol</code>
* <code>VertxHttpProtocol</code></p>

<p>The Vert.x 2 protocol module provides an event bus protocol implementation for <a href="http://vertx.io">Vert.x</a>. To add the
Vert.x 2 protocol to your Maven project, add the <code>copycat-vertx</code> module to your <code>pom.xml</code>:</p>

<pre><code>&lt;dependency&gt;
  &lt;groupId&gt;net.kuujo.copycat&lt;/groupId&gt;
  &lt;artifactId&gt;copycat-vertx&lt;/artifactId&gt;
  &lt;version&gt;0.5.0-SNAPSHOT&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>

<p>Then add the Vert.x 2 event bus protocol to your Copycat cluster configuration:</p>

<pre><code class="java">ClusterConfig cluster = new ClusterConfig()
  .withProtocol(new VertxEventBusProtocol("localhost", 1234));
</code></pre>

<p>You can also pass a <code>Vertx</code> instance in to the protocol:</p>

<pre><code class="java">ClusterConfig cluster = new ClusterConfig()
  .withProtocol(new VertxEventBusProtocol(vertx));
</code></pre>

<p>The Vert.x module also provides a <code>VertxEventLoopExecutor</code> which executes resource callbacks on the Vert.x event loop.
To ensure callbacks are executed on the Vert.x event loop context, add the <code>VertxEventLoopExecutor</code> to the resource
configuration:</p>

<pre><code class="java">EventLogConfig config = new EventLogConfig()
  .withLog(new FileLog()
    .withRetentionPolicy(new TimeBasedRetentionPolicy(1, TimeUnit.HOURS)))
  .withExecutor(new VertxEventLoopExecutor(vertx));
</code></pre>

<p>To configure the executor for the global Copycat cluster and instance, add an <code>Executor</code> to the <code>CopycatConfig</code>:</p>

<pre><code class="java">CopycatConfig config = new CopycatConfig()
  .withExecutor(new VertxEventLoopExecutor(vertx));
</code></pre>

<h3>Vert.x 3 protocol</h3>

<p>The Vert.x 3 protocol module provides an event bus protocol implementation for <a href="http://vertx.io">Vert.x 3</a>. To add the
Vert.x 3 protocol to your Maven project, add the <code>copycat-vertx3</code> module to your <code>pom.xml</code>:</p>

<pre><code>&lt;dependency&gt;
  &lt;groupId&gt;net.kuujo.copycat&lt;/groupId&gt;
  &lt;artifactId&gt;copycat-vertx3&lt;/artifactId&gt;
  &lt;version&gt;0.5.0-SNAPSHOT&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>

<p>Then add the Vert.x 3 event bus protocol to your Copycat cluster configuration:</p>

<pre><code class="java">ClusterConfig cluster = new ClusterConfig()
  .withProtocol(new VertxEventBusProtocol("localhost", 1234));
</code></pre>

<p>You can also pass a <code>Vertx</code> instance in to the protocol:</p>

<pre><code class="java">ClusterConfig cluster = new ClusterConfig()
  .withProtocol(new VertxEventBusProtocol(vertx));
</code></pre>

<p>The Vert.x 3 module also provides a <code>VertxEventLoopExecutor</code> which executes resource callbacks on the Vert.x event loop.
To ensure callbacks are executed on the Vert.x event loop context, add the <code>VertxEventLoopExecutor</code> to the resource
configuration:</p>

<pre><code class="java">EventLogConfig config = new EventLogConfig()
  .withLog(new FileLog()
    .withRetentionPolicy(new TimeBasedRetentionPolicy(1, TimeUnit.HOURS)))
  .withExecutor(new VertxEventLoopExecutor(vertx));
</code></pre>

<p>To configure the executor for the global Copycat cluster and instance, add an <code>Executor</code> to the <code>CopycatConfig</code>:</p>

<pre><code class="java">CopycatConfig config = new CopycatConfig()
  .withExecutor(new VertxEventLoopExecutor(vertx));
</code></pre>

<h2>Architecture</h2>

<p>Much of the preceding documentation has revolved around the features of Copycat and how to use them.
However, many users and potential contributors may want to get a better understanding of how Copycat works. This section
will detail precisely how Copycat performs tasks like leader election and log replication via the
<a href="https://raftconsensus.github.io/">Raft consensus protocol</a> and dynamic membership and failure detection via
<a href="http://en.wikipedia.org/wiki/Gossip_protocol">gossip</a>.</p>

<h3>Logs</h3>

<p>Logs are the center of the universe in the Copycat world. The global Copycat cluster and each of the resources contained
within it are all ultimately built on a consistent, Raft replicated log. Because logs are such a central component to
Copycat, much development effort has gone into the design and implementation of each of Copycat's logs.</p>

<p>Copycat's logs are designed with three features in mind:
* Fast writes
* Fast reads
* Fast compaction</p>

<p>In order to support these three vital functions, Copycat's logs are broken into segments. Each log may consist of
several segments of a configurable size, and each segment typically has a related index. The index is a simple list
of 8-bit pairs of integers indicating the entry index and position within a given segment. This allows Copycat to
quickly locate and read entries from the log.</p>

<p>Additionally, each log implementation supports <a href="#log-compaction">log compaction</a> on an arbitrary index.</p>

<h3>Strong consistency and Copycat's Raft consensus protocol</h3>

<p>Copycat uses a unique, extensible implementation of the
<a href="https://raftconsensus.github.io/">Raft distributed consensus algorithm</a> to provide strong consistency guarantees for
resource management, leader elections, and the log replication which underlies all of Copycat's resources.</p>

<p>Raft is the simpler implementation of only a few provable algorithms for achieving consensus in a distributed system
(the other more common implementation is <a href="http://en.wikipedia.org/wiki/Paxos_%28computer_science%29">Paxos</a>).
Designed for understandability, Raft uses a mixture of RPCs and timeouts to orchestrate leader election and replication
of a distributed log. In terms of the <a href="http://en.wikipedia.org/wiki/CAP_theorem">CAP theorem</a>, Raft - and by
extension - Copycat is a CP system, meaning in the face of a partition, Raft and Copycat favor consistency over
availability. This makes Raft a perfect fit for storing small amounts of mission critical state.</p>

<h4>Leader election</h4>

<p>In Raft, all writes are required to go through a cluster leader. Because Raft is designed to tolerate failures, this
means the algorithm must be designed to elect a leader when an existing leader's node crashes.</p>

<p>In Copycat, since each resource maintains its own replicated log, leader elections are performed among the
<a href="#active-member">active member</a> replicas for each resource in the cluster. This means at any given point in time,
leaders for various resources could reside on different members of the cluster. However,
<a href="#passive-members">passive members</a> cannot be elected leader as they do not participate in the Raft consensus algorithm.
For instance, in a cluster with three active members and ten passive members, the leader for an event log
could be active member <em>A</em>, while a state machine's leader could be active member <em>C</em>, but neither resource's leader
could be any passive member of the cluster. Copycat's <code>Cluster</code> and its related Raft implementation are designed to act
completely independently of other <code>Cluster</code> and Raft instances within the same Copycat instance.</p>

<p>In order to ensure consistency, leader election in Copycat is performed largely by comparing the logs of different
members of the cluster. When a member of the Copycat cluster stops receiving heartbeats from the cluster's leader, the
member transitions into the <code>CANDIDATE</code> state and begins a new election. Elections consist of sending a <code>PollRequest</code>
to each member of the cluster requesting a vote. Upon receiving a poll request, each member will compare information
about the candidate's log with its own log and either accept or reject the candidate's request based on that
information. If the candidate's log as as up-to-date or more recent than the polled member's log, the polled member
will accept the vote request. Otherwise, the polled member will reject the vote request. Once the candidate has received
successful votes from a majority of the cluster (including itself) it transitions to <code>LEADER</code> and begins accepting
requests and replicating the resource log.</p>

<p>Note that since Raft requires a leader to perform writes, during the leader election period the resource will be
unavailable. However, the period of time between a node crashing and a new leader being elected is typically very
small - on the order of milliseconds or seconds.</p>

<p>The consistency checks present in the Raft consensus algorithm ensure that the member with the most up-to-date log in
the cluster will be elected leader. In other words, through various restrictions on how logs are replicated and how
leaders are elected, Raft guarantees that <em>no member with an out of date log will be elected leader</em>, ensuring that once
entries are committed to the Copycat cluster, they are guaranteed to remain in the log until removed either via
compaction or deletion.</p>

<h4>Write replication</h4>

<p>Once a leader is elected via the Raft consensus protocol, the Copycat cluster can begin accepting new entries for the
log. All writes to any Copycat resource are <em>always</em> directed through the resource's cluster leader, and writes are
replicated from the leader to followers. This allows writes to the resource log to be coordinated from a single
location.</p>

<p>Commands - write operations - can be submitted to any member of the Copycat cluster. If a command is submitted to a
member that is not the leader, the command will be forwarded to the cluster leader. When the leader receives a command,
it immediately logs the entry to its local persistent log. Once the entry has been logged the leader attempts to
synchronously replicate the entry to a majority of the <a href="#active-members">active members</a> of the cluster. Once a
majority of the cluster has received the entry and written it to its log, the leader will apply the entry to its state
machine and reply with the result.</p>

<p>Note that writes to a Copycat resource are <em>not</em> synchronously replicated to <a href="#passive-members">passive members</a>.
Passive members receive only successfully committed log entries via a
<a href="#eventual-consistency-and-copycats-gossip-protocol">gossip protocol</a>.</p>

<p>Logging commands to a replicated log allows Copycat to recover from failures by simply replaying log entries. For
instance, when a state machine resource crashes and restarts, Copycat will automatically replay all of the entries
written to that state machine's log in order to rebuild the state machine state. Because all logs are built from
writes to a single leader, and because Raft guarantees that entries are replicated on a majority of the servers
prior to being applied to the state machine, all state machines within the Copycat cluster are guaranteed to receive
commands in the same order.</p>

<h4>Read consistency</h4>

<p>While Raft dictates that writes to the replicated log go through the resource's leader, reads allow for slightly more
flexibility depending on the specific use case. Copycat supports several read consistency modes.</p>

<p>In order to achieve strong consistency in any Raft cluster, though, queries - read operations - must go through the
cluster leader. This is because, as with any distributed system, there is always some period of time before full
consistency can be achieved. Once a leader commits a write to the replicated log and applies the entry to its state
machine, it still needs to notify followers that the entry has been committed. During that period of time, querying the
leader's state will result in fully consistent state, but reading state from followers will result in stale output.</p>

<p>Without additional measures, though, reading directly from the leader still does not guarantee consistency. Information
only travels at the speed of light, after all. What if the leader being queried is no longer the leader? Raft and
Copycat guard against this scenario by polling a majority of the active members of the cluster to ensure that the
leader is still who he thinks he is.</p>

<p>This all may sound very inefficient for reads, and it is. That's why Copycat provides some options for making
trade-offs. Copycat provides three different <code>Consistency</code> modes:
* <code>STRONG</code> - Queries go through the cluster leader. When handling a query request, the leader performs a leadership
  consistency check by polling a majority of the cluster. If any member of the cluster known of a leader with a higher
  term, the member will respond to the consistency check notifying the queried leader of the new leader, and the
  queried leader will ultimately step down. This consistency mode guarantees strong consistency for all queries
* <code>DEFAULT</code> - Queries go through the cluster leader, but the leader performs consistency checks only periodically. For
  most requests, this mode provides strong consistency. Because the default consistency mode uses leader lease
  timeouts that are less than the cluster's election timeout, only a unique set of circumstances could result in
  inconsistency when this mode is used. Specifically, the leader would theoretically need to be blocked due to log
  compaction on the most recent log segment (indicating misconfiguration) or some other long-running process while
  simultaneously a network partition occurs, another leader is elected, and the new leader accepts writes. That's a
  pretty crazy set of circumstances if you ask me :-)
* <code>WEAK</code> - Queries can be performed on any member of the cluster. When a member receives a query request, if the query's
  consistency mode is <code>WEAK</code> then the query will be immediately applied to that member's state machine. This rule
  also applies for <a href="#passive-members">passive members</a>.</p>

<p>While this functionality is not exposed by all resource APIs externally, Copycat allows read consistency to be specified
on a per-request basis via the <code>QueryRequest</code>.</p>

<h4>Log compaction</h4>

<p>One of the most important features of Raft is log compaction. While this is a feature that is often overlooked by many
Raft implementations, it is truly essential to the operation of a Raft based system in production. Over time, as
commands are written to Copycat's logs, the logs continue to grow. Log compaction is used to periodically reduce the
size of logs while maintaining the effective history of the logs.</p>

<p>Because Copycat's replicated log is designed to be agnostic about the structures built on top it, Copycat's Raft
implementation is effectively unopinionated about compaction. Event logs are designed to for arbitrary time or
size based compaction, while state logs and the state machines and data structures built on top of them are designed
to support compaction without losing important state information.</p>

<p>In order to support compaction, Copycat's logs are broken into segments. Once a log segment reaches a certain size,
the log creates a new segment and frees the written segment for compaction. Logs are compacted according to configurable
retention policies, but no policy can affect the segment that is currently being written to. This allows
historical segments to be compacted in a background thread while new segments are still being written.</p>

<p>For state logs, state machines, and the collections which are built on top of state machines, snapshots are used to
compact logs while preserving state. When the log grows larger than a single segment, a snapshot is taken of the state
machine state, serialized, placed at the <em>beginning</em> of the last segment, and all prior segments are permanently
deleted. This is a different pattern than is used by many other systems that support snapshots.</p>

<p>Because of how files are written, compacting a log segment technically requires rewriting the segment with the snapshot
at the beginning of the file. During this process, Copycat protects against data loss by creating a series of copies
of the log. If a failure occurs during compaction, persistent logs will recover gracefully by restoring the state of
the compacted segment prior to the start of compaction.</p>

<p>In some cases, a replica can become out of sync during the period in which the leader takes a snapshot and compacts
its log. In this case, since the leader has removed the entries prior to its snapshot it can no longer replicate those
entries to an out-of-sync follower. This is resolved by replicating the snapshot directly. By placing snapshots as
regular entries at the beginning of the log, snapshots become part of the log and thus are automatically replicated
via the Raft algorithm.</p>

<p>Additionally, when a resource crashes and recovers, the resource's log is replayed in order to rebuild the system's
state. By placing the snapshot at the beginning of the log, the snapshot is guaranteed to be the first entry applied
to the state machine.</p>

<h3>Eventual consistency and Copycat's gossip protocol</h3>

<p>While the <a href="#active-members">active members</a> of the Copycat cluster perform consistent replication of
<a href="#resources">resources</a> via the <a href="#strong-consistency-and-copycats-raft-consensus-protocol">Raft consensus protocol</a>,
<a href="#passive-members">passive members</a> receive replicated logs via a simple gossip protocol. This allows Copycat to
support clusters much larger than a standard Raft cluster by making some consistency concessions.</p>

<h4>Passive membership</h4>

<p>Every member of the Copycat cluster participates in a simple gossip protocol that aids in cluster membership detection.
When a <a href="#passive-members">passive member</a> joins the Copycat cluster, it immediately begins gossiping with the
configured <a href="#active-members">active members</a> of the cluster. This gossip causes the active members to add the new
passive member to the cluster configuration, which they gossip with other members of the cluster, including passive
members. All gossip is performed by periodically selecting three random members of the cluster with which to share
membership information. The gossip protocol uses a vector clock to share membership information between nodes. When
a member gossips membership information to another member, it sends member and version information for each member
of the cluster. When a member receives gossiped membership information, it updates its local membership according to
the version of each member in the vector clock. This helps prevent false positives due to out-of-date cluster membership
information.</p>

<h4>Log replication</h4>

<p>Committed entries in resource logs are replicated to passive members of the cluster via the gossip protocol. Each member
of the cluster - both active and passive members - participates in gossip-based log replication, periodically selecting
three random members with which to gossip. A vector clock on each node is used to determine which entries to replicate
to each member in the random set of members. When a member gossips with another member, it increments its local version
and sends its vector clock containing last known indexes of each other member with the gossip. When a member receives
gossip from another member, it updates its local vector clock with the received vector clock, appends replicated entries
if the entries are consistent with its local log, increments its local version, and replies with its updated vector
clock of member indexes. Tracking indexes via vector clocks helps reduce the number of duplicate entries within the
gossip replication protocol.</p>

<h4>Failure detection</h4>

<p>Just as Copycat uses gossip for membership, so too does the global cluster and resource clusters use gossip for failure
detection. The failure detection protocol is designed to reduce the risk of that false failures due to network
partitions. This is done by piggybacking failure information on to the cluster membership vector shared during gossip.
When an attempt to gossip with another member of the cluster fails for the first time, the <em>state</em> of that member in
the membership vector clock is changed to <code>SUSPICIOUS</code>. Additionally, the URI of the member that failed to communicate
with the suspicious member is added to a set of failed attempts in the membership vector clock. When a membership vector
containing a suspicious member is received by another member in the cluster, that member will immediately attempt to
gossip with the suspicious member. If gossip with the suspicious member fails, the member attempting the gossip will
again add its URI to the set of failed attempts. Once the set of failed attempts grows to a certain size (<code>3</code> by
default), the member's state will be changed <code>DEAD</code> and the member removed from the cluster.</p>

<h3><a href="#user-manual">User Manual</a></h3>

    </div>

    <div class="sidenav">
        <iframe width="100%" height="75" class="share_self"  frameborder="0" scrolling="no" src="http://widget.weibo.com/weiboshow/index.php?language=&width=0&height=75&fansRow=2&ptype=1&speed=0&skin=5&isTitle=0&noborder=0&isWeibo=0&isFans=0&uid=1855270953&verifier=375b89d6&dpc=1"></iframe>
    </div>

    <div class="sidenav">
        <h2>Blog</h2>
        <ul class="artical-list">
        
            <li><a href="/raft-copycat">ONOS 强一致性算法raft的java实现版copycat说明</a></li>
        
            <li><a href="/of-master-slave">ONOS OpenFlow控制器主备角色分析</a></li>
        
            <li><a href="/distribute-features1">ONOS 强一致性算法raft的java实现半copycat代码分析之leader election</a></li>
        
            <li><a href="/event-processing">ONOS 事件处理机制</a></li>
        
            <li><a href="/provider-providerRegistry-providerService">ONOS 南向抽象层分析</a></li>
        
            <li><a href="/dispatch-message">ONOS中收到OF消息后，分发消息流程分析</a></li>
        
            <li><a href="/channel-state">ONOS中Channel状态机分析</a></li>
        
            <li><a href="/switch-connection">ONOS中控制器与交换机建立连接的过程</a></li>
        
            <li><a href="/github-pages">使用Github Pages建独立博客</a></li>
        
            <li><a href="/why-blog">我为什么写博客？</a></li>
        
        </ul>

        <h2>Opinion</h2>
        <ul class="artical-list">
        
            <li><a href="/about-simplify">胡言乱语说简单</a></li>
        
        </ul>

        <h2>Project</h2>
        <ul class="artical-list">
        
            <li><a href="/tabby">Tabby</a></li>
        
            <li><a href="/notty-notes">Notty Notes</a></li>
        
            <li><a href="/overapi-cheatsheet">OverAPI</a></li>
        
            <li><a href="/raining-in-chrome">听雨</a></li>
        
        </ul>
    </div>
</div>

<script src="/js/post.js" type="text/javascript"></script>


    <script type="text/javascript">
        $(function(){
            $('.home-follow').click(function(e){
                e.preventDefault();

                if($('.home-contact').is(':visible')){
                    $('.home-contact').slideUp(100);
                }else{
                    $('.home-contact').slideDown(100);
                }
            });
        })
    </script>
</body>
</html>
