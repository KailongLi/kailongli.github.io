<!DOCTYPE html>
<html>
<head>
    <!--
    * Author:         BeiYuu
    -->
    <meta charset="utf-8" />
    <title>ONOS中收到OF消息后，分发消息流程分析 | kailongli.github.io</title>
    <meta name="author" content="KailongLi" />
    <meta name="renderer" content="webkit">
    <meta name="description" content="KailongLi's Blog" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0">
    <link rel="stylesheet" href="/css/default.css" type="text/css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon" />
    <link rel="alternate" type="application/atom+xml" title="Recent Entries" href="/atom.xml" />
    <script src="/js/jquery-1.7.1.min.js" type="text/javascript"></script>
</head>
<body>

    <div class="home-menu">
        <div class="home-icon-con">
            <a class="home-menu-icon" href="/">李开龙</a>
            <a class="home-follow" href="#" title="Contact Me">+</a>
        </div>
        <div class="home-contact">
            <a href="http://weibo.com/beiyuu/" target="_blank" style="margin-left:-5px;"><img src="http://www.weibo.com/favicon.ico" alt="" width="25"/></a>
            <a href="http://www.douban.com/people/beiyuu/" target="_blank" style="text-align:center;"><img src="http://www.douban.com/favicon.ico" alt="" width="22"/></a>
            <a href="http://instagram.com/beiyuu/" target="_blank" style="text-align:right"><img src="http://d36xtkk24g8jdx.cloudfront.net/bluebar/00c6602/images/ico/favicon.ico" alt="" width="22"/></a>
        </div>
    </div>

    <link rel="stylesheet" href="/js/prettify/prettify.css" />
<style type="text/css">
    body { background:#e8e8e8; }
    @media screen and (max-width: 750px){
        body { background:#fff; }
    }
    @media screen and (max-width: 1020px){
        body { background:#fff; }
    }
</style>

<div id="content">
    <div class="entry">
        <h1 class="entry-title"><a href="/dispatch-message" title="ONOS中收到OF消息后，分发消息流程分析">ONOS中收到OF消息后，分发消息流程分析</a></h1>
        <p class="entry-date">2015-04-16</p>
        <p>首先介绍代码是如何走到消息处理的方法，然后分析分发消息的规则的代码的结构和语法，最后分析这样设计代码的好处。</p>

<h2>代码如何走到消息处理的方法</h2>

<p><img src="/images/githubpages/dispatch%20message%20function.png" alt="dispatch message function" /></p>

<p><li>① OFChannelHandler在Channel状态WAIT_DESCRIPTION_STAT_REPLY中调用Controller类的getOFSwitchInstance方法来获取交换机实例;</li>
<li>② Controller类的getOFSwitchInstance方法，则调用DriverManager的静态方法getSwitch来获取不同厂家实现的交换机实例，获取的原则是基于OFDescStatsReply消息中的“厂家信息”和“硬件信息”。注意：在实例化交换机之后，将OpenFlowAgent实例赋给了该交换机，其中OpenFlowAgent实例的产生是在OpenFlowControllerImpl类的内部类OpenFlowSwitchAgent类实例化的，见⑤。</li>
<li>③ 这里的driver意味着对接不同厂家的OF交换机，上图只是列出了少数几种OF交换机，例如：支持OF_13的OVS，OF_10的OVS和光的OF交换机</li>
<li>④ 这里的OF交换机都继承了AbstractOpenFlowSwitch的handleMessage方法，而handleMessage方法调用了就是agent的processMessage方法，然后processMessage方法调用了processPacket方法，在processPacket方法中，就是处理消息分发的分发口</li></p>

<h2>分析分发消息的规则的代码的结构和语法</h2>

<h3>分发消息的规则</h3>

<ul> 在 processPacket 方法中：
<li>当收到 OFPortStatus 消息，通知OpenFlowSwitchLister的portChanged方法。</li>
<li>当收到OFFeaturesPeply消息，通知OpenFlowSwitchLister的switchChanged方法。</li>
<li>当收到OFPacketIn消息，通知PacketListener的handlePacket方法。</li>
<li>当收到OFFlowRemoved消息和OFError消息，交给OpenFlowEventListener的handleMessage来处理。</li>
<li>当收到OFBarrierReply消息，交给OpenFlowEventListener的handleMessage来处理。</li>
<li>当收到OFExperimenter消息，仅仅处理experimenter为0x748771的扩展光消息，最后交给交给 OpenFlowSwitchListener 的 portChanged 来处理。</li>   

当收到OFStatsReply消息时，根据其消息类型来进行分类处理：

<li>如果类型为PortDesc，通知OpenFlowSwitchLister的switchChanged方法；</li>
<li>如果类型为Flow，首先构造OFFlowStateReply消息，然后调用OpenFlowEventListener的handleMessage来处理这个消息；</li>
<li>如果类型为Group，首先构造 OFGroupStatsReply 消息，然后调用OpenFlowEventListener的handleMessage来处理这个消息；</li>
<li>如果类型为GROUP_DESC，首先构造 OFGroupDescStatsReply 消息，然后调用OpenFlowEventListener的handleMessage来处理这个消息；</li>
<li>如果类型为PORT，直接调用OpenFlowEventListener的handleMessage来处理这个消息。</li>
</ul>


<h3>代码结构</h3>

<p>由上面的分发规则，我们可以看出，许多OF消息都交给了不同的listener的不同方法来进行处理，例如OFSwitchListener的portChanged和switchChanged方法，OpenFlowEventListener的handleMessage方法，PacketListener的handlePacket方法等。下面主要分析各个APP如何拿到这些OF消息，并且同一个消息在各个APP之间处理的先后顺序是如何定义的。</p>

<p><img src="/images/githubpages/packet-in-from-south-to-app.png" alt="packet-in-from-south-to-app" />
以 Packet-in 处理为例来说明上面两个问题，</p>

<h4>South-OF Layer</h4>

<p>控制器收到OFPacketIn的消息后，遍历所有的 ofPacketListener 容器中的 Packetlistener ，调用其中的 handlePacket 方法来处理 Packet-in 消息，</p>

<pre><code>for (PacketListener p : ofPacketListener.values()) {
    p.handlePacket(pktCtx);
}
</code></pre>

<p>那么问题来了，ofPacketListener 中的 listener 什么时候加进来的呢？在 OpenFlowController 接口中提供了 addPacketListener 方法，以便往 ofPacketListener 容器中加入 PacketListener 。</p>

<h4>Provider Layer</h4>

<p>OpenFlowPacketProvider 类的属性 controller 实例化 OpenFlowController，采用 OSGI 的注解方式，来添加对 OpenFlowControllerImpl 的引用</p>

<pre><code>@Reference(cardinality = ReferenceCardinality.MANDATORY_UNARY)
protected OpenFlowController controller;
</code></pre>

<p>然后在 OpenFlowPacketProvider 启动的时候，将实例化的 listener 加入到 ofPacketListener 容器中。</p>

<pre><code>@Activate
public void activate() {
    providerService = providerRegistry.register(this);
    controller.addPacketListener(20, listener);
    log.info("Started");
}
</code></pre>

<p>其中 OpenFlowPacketProvider 的内部类 InternalPacketProvider 实现 Packetlistener 接口， handlePacket 方法：</p>

<pre><code>@Override
public void handlePacket(OpenFlowPacketContext pktCtx) {
    DeviceId id = DeviceId.deviceId(Dpid.uri(pktCtx.dpid().value()));

    DefaultInboundPacket inPkt = new DefaultInboundPacket(
            new ConnectPoint(id, PortNumber.portNumber(pktCtx.inPort())),
            pktCtx.parsed(), ByteBuffer.wrap(pktCtx.unparsed()));

    DefaultOutboundPacket outPkt = null;
    if (!pktCtx.isBuffered()) {
        outPkt = new DefaultOutboundPacket(id, null,
                ByteBuffer.wrap(pktCtx.unparsed()));
    }

    OpenFlowCorePacketContext corePktCtx =
            new OpenFlowCorePacketContext(System.currentTimeMillis(),
                    inPkt, outPkt, pktCtx.isHandled(), pktCtx);
    providerService.processPacket(corePktCtx);
}
</code></pre>

<p>发现最后还是调用 providerService 的 processPacket 方法，在 OpenFlowPacketProvider 启动的时候， <code>providerService = providerRegistry.register(this);</code> 这里涉及到 <code>provider</code> 、<code>providerRegistry</code> 和 <code>providerService</code> 这三个概念，它们主要为了管理 <code>provider</code> ，下篇博客将详细讲解它的机制。就现在这种情况， providerRegistry 实例化为 PacketManager ， providerService 实例化为 PacketManager 的内部类 InternalPacketProviderService ，而这两个类属于 Core Layer，因此，调用的 InternalPacketProviderService 的 processPacket 方法。</p>

<h4>Core Layer</h4>

<p>在 InternalPacketProviderService 的 processPacket 方法中，遍历 processors 容器中所有的 PacketProcessor 的 process 方法来处理。</p>

<pre><code>@Override
public void processPacket(PacketContext context) {
    // TODO filter packets sent to processors based on registrations
    for (PacketProcessor processor : processors.values()) {
        processor.process(context);
    }
}
</code></pre>

<p>这种代码的结构（红色部分）类似于 South-OF Layer 到 Provider Layer 的跨层调用结构（紫色部分），这里将不再赘述。这种代码的结构最大的好处就是层间解耦。</p>

<h4>App Layer</h4>

<p>在 App Layer 中，提供了两个 APP 作为例子来说明第二个问题，对于同一个 OF 消息，各个 APP 处理的先后顺序，在 addProcessor 方法中，除了添加各个 APP 的 processor 之外，还有另外一个属性，那就是优先级，用来处理调用顺序的问题。在 ProxyArp 这个 APP 中，优先级为 PacketProcessor.ADVISOR_MAX + 1</p>

<pre><code>packetService.addProcessor(processor, PacketProcessor.ADVISOR_MAX + 1);
</code></pre>

<p>在 BGPRouter 这个 APP 中，优先级为 PacketProcessor.ADVISOR_MAX + 4</p>

<pre><code>packetService.addProcessor(processor, PacketProcessor.ADVISOR_MAX + 4);
</code></pre>

<p>优先级越低，越先处理，其原理是利用了 <a href="http://stackoverflow.com/questions/24372257/implementing-priority-queue-using-hashmap" title="HashMap">HashMap</a> 的有序性，对于同优先级的 processer ，后加入的 processer 将覆盖前面的 processor 。</p>

    </div>

    <div class="sidenav">
        <iframe width="100%" height="75" class="share_self"  frameborder="0" scrolling="no" src="http://widget.weibo.com/weiboshow/index.php?language=&width=0&height=75&fansRow=2&ptype=1&speed=0&skin=5&isTitle=0&noborder=0&isWeibo=0&isFans=0&uid=1855270953&verifier=375b89d6&dpc=1"></iframe>
    </div>

    <div class="sidenav">
        <h2>Blog</h2>
        <ul class="artical-list">
        
            <li><a href="/provider-providerRegistry-providerService">ONOS中收到OF消息后，分发消息流程分析</a></li>
        
            <li><a href="/dispatch-message">ONOS中收到OF消息后，分发消息流程分析</a></li>
        
            <li><a href="/channel-state">ONOS中Channel状态机分析</a></li>
        
            <li><a href="/switch-connection">ONOS中控制器与交换机建立连接的过程</a></li>
        
            <li><a href="/github-pages">使用Github Pages建独立博客</a></li>
        
            <li><a href="/why-blog">我为什么写博客？</a></li>
        
        </ul>

        <h2>Opinion</h2>
        <ul class="artical-list">
        
            <li><a href="/about-simplify">胡言乱语说简单</a></li>
        
        </ul>

        <h2>Project</h2>
        <ul class="artical-list">
        
            <li><a href="/tabby">Tabby</a></li>
        
            <li><a href="/notty-notes">Notty Notes</a></li>
        
            <li><a href="/overapi-cheatsheet">OverAPI</a></li>
        
            <li><a href="/raining-in-chrome">听雨</a></li>
        
        </ul>
    </div>
</div>

<script src="/js/post.js" type="text/javascript"></script>


    <script type="text/javascript">
        $(function(){
            $('.home-follow').click(function(e){
                e.preventDefault();

                if($('.home-contact').is(':visible')){
                    $('.home-contact').slideUp(100);
                }else{
                    $('.home-contact').slideDown(100);
                }
            });
        })
    </script>
</body>
</html>
