<!DOCTYPE html>
<html>
<head>
    <!--
    * Author:         BeiYuu
    -->
    <meta charset="utf-8" />
    <title>ONOS 事件处理机制 | kailongli.github.io</title>
    <meta name="author" content="KailongLi" />
    <meta name="renderer" content="webkit">
    <meta name="description" content="KailongLi's Blog" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0">
    <link rel="stylesheet" href="/css/default.css" type="text/css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon" />
    <link rel="alternate" type="application/atom+xml" title="Recent Entries" href="/atom.xml" />
    <script src="/js/jquery-1.7.1.min.js" type="text/javascript"></script>
</head>
<body>

    <div class="home-menu">
        <div class="home-icon-con">
            <a class="home-menu-icon" href="/">李开龙</a>
            <a class="home-follow" href="#" title="Contact Me">+</a>
        </div>
        <div class="home-contact">
            <a href="http://weibo.com/beiyuu/" target="_blank" style="margin-left:-5px;"><img src="http://www.weibo.com/favicon.ico" alt="" width="25"/></a>
            <a href="http://www.douban.com/people/beiyuu/" target="_blank" style="text-align:center;"><img src="http://www.douban.com/favicon.ico" alt="" width="22"/></a>
            <a href="http://instagram.com/beiyuu/" target="_blank" style="text-align:right"><img src="http://d36xtkk24g8jdx.cloudfront.net/bluebar/00c6602/images/ico/favicon.ico" alt="" width="22"/></a>
        </div>
    </div>

    <link rel="stylesheet" href="/js/prettify/prettify.css" />
<style type="text/css">
    body { background:#e8e8e8; }
    @media screen and (max-width: 750px){
        body { background:#fff; }
    }
    @media screen and (max-width: 1020px){
        body { background:#fff; }
    }
</style>

<div id="content">
    <div class="entry">
        <h1 class="entry-title"><a href="/event-processing" title="ONOS 事件处理机制">ONOS 事件处理机制</a></h1>
        <p class="entry-date">2015-04-23</p>
        <p>本篇博客首先介绍DeviceEvent的处理流程的例子，然后分析各个模块的含义，最后抽象事件处理流程。</p>

<h2>事件处理流程</h2>

<p><img src="/images/githubpages/event%20processing.png" alt="event processing" /></p>

<p>上面的图有些小，请见谅。事件处理的流程如下：</p>

<p>①DeviceManager启动时调用EventDeliveryService的addSink方法将处理DeviceEvent的EventSink (AbstractListenerRegistry)添加进来。<br/>
②CoreEventDispatcher启动时一直不停地从Event队列中，取事件，然后根据事件的类的类型，来获取相应的EventSink，然后调用eventSink 的process方法来处理事件，这是消费者部分。<br/>
③BgpRouter的内部类InnerDeviceListener实现DeviceListener，主要为了实现处理event的event方法。<br/>
④BgpRouter调用DeviceService接口的addListener方法来将InnerDeviceListener实例添加进来。<br/>
⑤DeviceManager实现DeviceService接口的addListener方法，调用AbstractListenerRegistry类的addListener方法，将InnerDeviceListener放入一个listeners集合中。<br/>
⑥DeviceManager类的内部类InternalDeviceProviderService，感知到Device消息后，调用EventDispatcher接口的post(Event)方法来投递事件。注意在EventDispatcher接口的实现类CoreEventDispatcher中实现post方法，只是将event添加到Event队列中，至此，生产-消费者模式的生产部分已经完成。<br/>
⑦结合②，eventSink的process方法遍历所有的listeners集合，调用listener的event方法，也就是BgpRouter的内部类实现的event方法。</p>

<h2>各个模块的含义</h2>

<h4>EventListener<E extends Event></h4>

<p>EventListener 接口中，只提供了一个 event 方法，它用来对特定事件作出特定的处理。其中特定的事件是由泛型 <E extends Event> 来的， DeviceListener 接口的定义如下：</p>

<pre><code>public interface DeviceListener extends EventListener&lt;DeviceEvent&gt; {
}
</code></pre>

<p>特定的处理则是由各个APP来实现 DeviceListener 接口的 event 方法，注意这里有个小技巧，各个APP，例如 BgpRouter ，使用内部类 InnerDeviceListener 来实现 DeviceListener ，为什么要使用内部类来实现 DeviceListener 呢？如果只是需要一个接口的引用，为什么不通过外围类来实现那个接口呢？这个问题从《JAVA编程思想》中得到答案：</p>

<blockquote><p>每个内部类都能够独立地继承自一个（接口的）实现，所以无论外围类是否已经继承了某个（接口的）实现，对于内部类都没有影响。</p></blockquote>

<p>如果没有内部类提供的、可以继承多个具体的或抽象的类的能力，一些设计与编程问题就很难解决。从这个角度看，内部类使得多重继承的解决方案变得完整。接口解决了部分问题，而内部类有效地实现了“多重继承”。也就是说，内部类允许继承多个非接口类型。举个例子：在 TopologyMetrics 这个类中，假如它需要同时监听 Device 接口和 Host 接口，那么它需要实现 DeviceListener 和 HostListener 这两个接口，而这两个接口都拥有同样的方法 event ，如果仅用外部类来实现这两个接口，那么一个 event 方法会覆盖另外一个 event 方法，因此只能用内部类，来独立地实现某个接口。</p>

<p>总结 EventListener<E extends Event> 的作用：
* 它给其他特定事件接口（例如DeviceEventListener）来继承出特定的 EventListener；
* 继承出来的接口给不同APP来实现，override event 方法，来实现对 event 的特定处理。</p>

<h4>EventSink</h4>

<p>EventSink主要提供处理特定事件类型处理方法的能力，在ONOS代码中只有 AbstractListenerRegistry 实现 EventSink 接口。注意 AbstractListenerRegistry 是一个泛型类，</p>

<pre><code>public class AbstractListenerRegistry&lt;E extends Event, L extends EventListener&lt;E&gt;&gt; implements EventSink&lt;E&gt; {
    ……
}
</code></pre>

<p>在 AbstractListenerRegistry 类中，实现事件处理的 process 方法实际上是调用了 EventListener 的 event 方法，具体的做法是遍历 EventListener 集合中所有的 listener ，EventListener集合即 EventListener Sink，因此 AbstractListenerRegistry 类还需要提供将其他 listener 添加到 EventListener Sink 中的方法 addListener , 注意对于特定类型的事件， EventListener 集合为特定类型的 EventListener 集合。</p>

<p>总结 EventSink （AbstractListenerRegistry）的作用：
* 为不同的事件提供 EventSink 的模板；
* EventSink 提供往 EventListener Sink 中添加 EventListener 的方法；
* 封装 EventListener Sink 中所有 EventListener 处理 event 的方法。</p>

<h4>EventDeliveryService</h4>

<p>EventDeliveryService 、EventDispatcher 、 EventSinkRegistry 这三个接口的关系如下：</p>

<pre><code>public interface EventDeliveryService extends EventDispatcher, EventSinkRegistry {
}
</code></pre>

<p>EventDeliveryService 继承了 EventDispatcher 和 EventSinkRegistry 的作用，并且对外提供接口，提供投递事件的接口和 EventSink 的注册机制。EventSinkRegistry 接口的默认实现  DefaultEventSinkRegistry 说明了 EventSink 的注册机制：</p>

<pre><code>@Override
public &lt;E extends Event&gt; void addSink(Class&lt;E&gt; eventClass, EventSink&lt;E&gt; sink) {
    checkNotNull(eventClass, "Event class cannot be null");
    checkNotNull(sink, "Event sink cannot be null");
    checkArgument(!sinks.containsKey(eventClass),
                  "Event sink already registered for %s", eventClass.getName());
    sinks.put(eventClass, sink);
}
</code></pre>

<p>根据事件类型来注册 EventSink ，一种事件类型只能有一个 EventSink ，那么解注册方法也是这样的机制，另外还提供两个方法：根据事件类型获取 EventSink 和 获取所有事件类型的方法。</p>

<p>由最上的类图可知： 事件处理机制的核心 CoreEventDispatcher 实现了接口 EventDeliveryService 和继承了 EventSinkRegistry 接口的默认实现  DefaultEventSinkRegistry ，它采用的是生产-消费者模式， post 方法用来将事件添加到事件队列，作为生产者一部分，另外内部类 DispatchLoop 类，不停地从事件队列中取出事件来进行处理，作为消费者一部分。</p>

<p>总结 EventDeliveryService（ CoreEventDispatcher ）的作用：
* 提供EventSink注册机制；
* 作为事件处理机制的核心，实现生产-消费者模式。</p>

<p>经过以上分析，总结出事件对象模型关系：
<img src="/images/githubpages/event%20model.png" alt="event model" /></p>

<h2>抽象事件处理流程</h2>

<p><img src="/images/githubpages/Event%20processing%20procedure.png" alt="Event processing procedure" /></p>

    </div>

    <div class="sidenav">
        <iframe width="100%" height="75" class="share_self"  frameborder="0" scrolling="no" src="http://widget.weibo.com/weiboshow/index.php?language=&width=0&height=75&fansRow=2&ptype=1&speed=0&skin=5&isTitle=0&noborder=0&isWeibo=0&isFans=0&uid=1855270953&verifier=375b89d6&dpc=1"></iframe>
    </div>

    <div class="sidenav">
        <h2>Blog</h2>
        <ul class="artical-list">
        
            <li><a href="/raft-copycat">ONOS 强一致性算法raft的java实现版copycat说明</a></li>
        
            <li><a href="/of-master-slave">ONOS OpenFlow控制器主备角色分析</a></li>
        
            <li><a href="/distribute-features1">ONOS 强一致性算法raft的java实现半copycat代码分析之leader election</a></li>
        
            <li><a href="/event-processing">ONOS 事件处理机制</a></li>
        
            <li><a href="/provider-providerRegistry-providerService">ONOS 南向抽象层分析</a></li>
        
            <li><a href="/dispatch-message">ONOS中收到OF消息后，分发消息流程分析</a></li>
        
            <li><a href="/channel-state">ONOS中Channel状态机分析</a></li>
        
            <li><a href="/switch-connection">ONOS中控制器与交换机建立连接的过程</a></li>
        
            <li><a href="/github-pages">使用Github Pages建独立博客</a></li>
        
            <li><a href="/why-blog">我为什么写博客？</a></li>
        
        </ul>

        <h2>Opinion</h2>
        <ul class="artical-list">
        
            <li><a href="/about-simplify">胡言乱语说简单</a></li>
        
        </ul>

        <h2>Project</h2>
        <ul class="artical-list">
        
            <li><a href="/tabby">Tabby</a></li>
        
            <li><a href="/notty-notes">Notty Notes</a></li>
        
            <li><a href="/overapi-cheatsheet">OverAPI</a></li>
        
            <li><a href="/raining-in-chrome">听雨</a></li>
        
        </ul>
    </div>
</div>

<script src="/js/post.js" type="text/javascript"></script>


    <script type="text/javascript">
        $(function(){
            $('.home-follow').click(function(e){
                e.preventDefault();

                if($('.home-contact').is(':visible')){
                    $('.home-contact').slideUp(100);
                }else{
                    $('.home-contact').slideDown(100);
                }
            });
        })
    </script>
</body>
</html>
