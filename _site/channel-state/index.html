<!DOCTYPE html>
<html>
<head>
    <!--
    * Author:         BeiYuu
    -->
    <meta charset="utf-8" />
    <title>ONOS中Channel状态机分析 | kailongli.github.io</title>
    <meta name="author" content="KailongLi" />
    <meta name="renderer" content="webkit">
    <meta name="description" content="KailongLi's Blog" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0">
    <link rel="stylesheet" href="/css/default.css" type="text/css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon" />
    <link rel="alternate" type="application/atom+xml" title="Recent Entries" href="/atom.xml" />
    <script src="/js/jquery-1.7.1.min.js" type="text/javascript"></script>
</head>
<body>

    <div class="home-menu">
        <div class="home-icon-con">
            <a class="home-menu-icon" href="/">李开龙</a>
            <a class="home-follow" href="#" title="Contact Me">+</a>
        </div>
        <div class="home-contact">
            <a href="http://weibo.com/beiyuu/" target="_blank" style="margin-left:-5px;"><img src="http://www.weibo.com/favicon.ico" alt="" width="25"/></a>
            <a href="http://www.douban.com/people/beiyuu/" target="_blank" style="text-align:center;"><img src="http://www.douban.com/favicon.ico" alt="" width="22"/></a>
            <a href="http://instagram.com/beiyuu/" target="_blank" style="text-align:right"><img src="http://d36xtkk24g8jdx.cloudfront.net/bluebar/00c6602/images/ico/favicon.ico" alt="" width="22"/></a>
        </div>
    </div>

    <link rel="stylesheet" href="/js/prettify/prettify.css" />
<style type="text/css">
    body { background:#e8e8e8; }
    @media screen and (max-width: 750px){
        body { background:#fff; }
    }
    @media screen and (max-width: 1020px){
        body { background:#fff; }
    }
</style>

<div id="content">
    <div class="entry">
        <h1 class="entry-title"><a href="/channel-state" title="ONOS中Channel状态机分析">ONOS中Channel状态机分析</a></h1>
        <p class="entry-date">2015-04-08</p>
        <p>首先分析状态机代码的结构和语法，然后分析各个状态的变化，及其涉及到的OF消息的含义。</p>

<h2>状态机代码的结构和语法分析</h2>

<p>控制器启动的入口函数为</p>

<pre><code>enum ChannelState {
    ① WAIT_HELLO(false) {
        @Override
        void processOFHello(OFChannelHandler h, OFHello m)
                throws IOException {
            // TODO We could check for the optional bitmap, but for now
            // we are just checking the version number.
            if (m.getVersion() == OFVersion.OF_13) {
                log.debug("Received {} Hello from {}", m.getVersion(),
                        h.channel.getRemoteAddress());
                h.sendHandshakeHelloMessage();
                h.ofVersion = OFVersion.OF_13;
            } else if (m.getVersion() == OFVersion.OF_10) {
                log.debug("Received {} Hello from {} - switching to OF "
                        + "version 1.0", m.getVersion(),
                        h.channel.getRemoteAddress());
                OFHello hi =
                        h.factory10.buildHello()
                                .setXid(h.handshakeTransactionIds--)
                                .build();
                h.channel.write(Collections.singletonList(hi));
                h.ofVersion = OFVersion.OF_10;
            } else {
                log.error("Received Hello of version {} from switch at {}. "
                        + "This controller works with OF1.0 and OF1.3 "
                        + "switches. Disconnecting switch ...",
                        m.getVersion(), h.channel.getRemoteAddress());
                h.channel.disconnect();
                return;
            }
            h.sendHandshakeFeaturesRequestMessage();
            h.setState(WAIT_FEATURES_REPLY);
        }
        @Override
        void processOFFeaturesReply(OFChannelHandler h, OFFeaturesReply  m)
                throws IOException, SwitchStateException {
            illegalMessageReceived(h, m);
        }
        ……
    };
    ……

    ② private final boolean handshakeComplete;
    ChannelState(boolean handshakeComplete) {
        this.handshakeComplete = handshakeComplete;
    }

    ③ void processOFMessage(OFChannelHandler h, OFMessage m)
            throws IOException, SwitchStateException {
        switch(m.getType()) {
        case HELLO:
            processOFHello(h, (OFHello) m);
            break;
        case BARRIER_REPLY:
            processOFBarrierReply(h, (OFBarrierReply) m);
            break;
        case ECHO_REPLY:
            processOFEchoReply(h, (OFEchoReply) m);
            break;
        ……
        default:
            illegalMessageReceived(h, m);
            break;
        }
    }

    void processOFHello(OFChannelHandler h, OFHello m)
            throws IOException, SwitchStateException {
        // we only expect hello in the WAIT_HELLO state
        illegalMessageReceived(h, m);
    }

    // no default implementation. Every state needs to handle it.
    abstract void processOFPortStatus(OFChannelHandler h, OFPortStatus m)
            throws IOException, SwitchStateException;
}
</code></pre>

<p>分析ChannelState这个枚举类的结构：这里首先包含用来表示状态的枚举值WAIT_HELLO。然后定义了handshakeComplete这个属性，用来标记是否完成控制器与交换机的握手过程，由于它是final类型的，所以它必须由构造函数来初始化，于是WAIT_HELLO(false)表示在WAIT_HELLO这个状态下，还没有完成握手。最后定义了processOFMessage(OFChannelHandler h, OFMessage m)这个方法，它用来根据不同的OF消息来进行不同的处理。注意处理方法的不同定义，processOFPortStatus为abstract类型，processOFHello则不是，于是，有两个疑问：</p>

<ul>
    <li>为什么有些处理方法要声明为abstract呢？</li>
    <li>为什么在① WAIT_HELLO中可以复写processOFHello这个非abstract方法呢？</li>
</ul>


<p>对于第一个问题：注释已经说得很明白，在各个状态下收到的OF消息中，有些OF消息有默认的处理方法，而有些OF消息则没有默认的处理方法。</p>

<p>对于第二个问题：采用倒推的思路，在什么情况下可以复写非abstract方法呢？答案是一个类extends另外一个类。于是，可以得出WAIT_HELLO(enum实例)像一个独特的类，并且WAIT_HELLO extends ChannelState。《JAVA编程思想》里描述：编译器不允许我们将一个enum实例当做class类型，因为每个enum元素（WAIT_HELLO）是一个ChannelState类型的static final实例，同时，由于它们是static实例，无法访问外部类的非static元素或方法，所以对于内部的enum实例而言，其行为与一般的内部类并不相同。除了实现abstract方法以外，程序员还可以覆盖常量相关的方法。</p>

<h2>状态机各个状态变化分析</h2>

<p><img src="/images/githubpages/channel%20state%20machine.png" alt="channel state machine" /></p>

<p>上面这张图channel状态机的流转图，下面将解释这张图的含义。</p>

<p>在ChannelState为INIT状态下，交换机与控制器还没有建立连接，在这个状态下，收到的任何OF消息都是不正常的。由于processOFError和processOFPortStatus这两个方法是定义的abstract，所以这两个方法必须复写。对于收到其他的OF消息，统一采用默认的处理illegalMessageReceived(h, m)。</p>

<p>在ChannelState为WAIT_HELLO状态下，控制器主要处理接收到的OFHello消息，进行版本协商过程。在OFChannelHandler.channelConnected方法中，控制器注释了发送OFHello消息的代码，而只是等待交换机主动发送OFHello消息，这样做的好处是简化流程，避免一些可能出现的异常场景，这也是需要交换机在与控制器建立连接后，能够主动发送OFHello消息的能力。处理OFHello消息的具体流程如下图
<img src="/images/githubpages/WAIT_HELLO_processOFHello.png" alt="WAIT_HELLO_processOFHello" />
除了OFHello消息之外，如果收到来自交换机的Asynchronous消息(PacketIn/FlowRemoved/PortStatus)，这是有可能的，因为OF通道建立好了之后，交换机状态发生变化，那么就会发送这些Asynchronous消息给控制器，但是控制器收到之后处理不了，因为控制器还没有和交换机握手成功了；如果收到来自交换机的Symmetric消息OFError，直接断开连接；如果收到来自交换机的Symmetric消息OFEchoRequest，则相应地回OFEchoReply；如果收到来自交换机的Symmetric消息OFEchoReply，控制器什么都不处理；如果收到Controller-to-Switch信息（OFFeaturesReply和OFStatisticsReply），则断开连接。</p>

<p>在ChannelState为WAIT_FEATURES状态下，控制器主要处理接收到的OFFeaturesReply消息，一是获取DPID，二是将OFFeaturesReply消息暂存起来，以供后期判断交换机类型，获取相应的交换机实例。处理OFFeaturesReply消息的具体流程如下图
<img src="/images/githubpages/WAIT_FEATURES_REPLY_processOFFeaturesReply.png" alt="WAIT_FEATURES_REPLY_processOFFeaturesReply" />
对于OF10协议，先要下发Controller-to-Switch类型的OFSetConfig消息（消息中的miss_send_len为OFPCML_NO_BUFFER,即0xffff），其目的是让交换机能够上报完整的packet_in报文，注意：这里上报到控制器的packet_in报文是指没有用output action到OFPP_CONTROLLER的场景；然后下发Controller-to-Switch类型的OFBarrierRequest消息，保证OFSetConfig消息先下发完成；最后下发OFGetConfigRequest消息，由于前面使用OFBarrierRequest消息，这保证了OFSetConfig消息一定在OFGetConfigRequest消息前下发完成，因此在这三条消息下发完成之后，进入WAIT_CONFIG_REPLY状态，等待接收OFGetConfigReply消息，当接收到了OFGetConfigReply消息，查看OFSetConfig消息中设置的字段OFPCML_NO_BUFFER,即0xffff是否成功。</p>

<ul>
<li>收获：控制器给交换机下发的配置消息，如何检验是否下发成功？对于交换机能够回复的消息，那么等待交换机回复的消息来确认控制器给交换机下发的消息是否成功；对于交换机不回复的，则采用OFBarrierRequest来保证控制器下发的消息完成，然后下发查询消息，等待交换机回复消息，再来确认控制器下发的配置消息是否成功。</li>
</ul>


<p>对于OF13协议，下发OFPortDescRequest消息，然后将控制器的状态设置为WAIT_PORT_DESC_REPLY，在WAIT_PORT_DESC_REPLY中处理流程如下：
<img src="/images/githubpages/WAIT_PORT_DESC_REPLY_processOFStatisticsReply.png" alt="WAIT_PORT_DESC_REPLY_processOFStatisticsReply" />
最后回到了WAIT_CONFIG_REPLY，对比OF_13比OF_10多了一个WAIT_PORT_DESC_REPLY的状态，是因为控制器要暂存OFStatsReply消息，以便后续根据OFStatsReply消息的mfr_desc(Manufacturer description)和hw_desc（Hardware description）判断该交换机是Open vSwitch还是其他硬件交换机。</p>

    </div>

    <div class="sidenav">
        <iframe width="100%" height="75" class="share_self"  frameborder="0" scrolling="no" src="http://widget.weibo.com/weiboshow/index.php?language=&width=0&height=75&fansRow=2&ptype=1&speed=0&skin=5&isTitle=0&noborder=0&isWeibo=0&isFans=0&uid=1855270953&verifier=375b89d6&dpc=1"></iframe>
    </div>

    <div class="sidenav">
        <h2>Blog</h2>
        <ul class="artical-list">
        
            <li><a href="/channel-state">ONOS中Channel状态机分析</a></li>
        
            <li><a href="/switch-connection">ONOS中控制器与交换机建立连接的过程</a></li>
        
            <li><a href="/github-pages">使用Github Pages建独立博客</a></li>
        
            <li><a href="/why-blog">我为什么写博客？</a></li>
        
        </ul>

        <h2>Opinion</h2>
        <ul class="artical-list">
        
            <li><a href="/about-simplify">胡言乱语说简单</a></li>
        
        </ul>

        <h2>Project</h2>
        <ul class="artical-list">
        
            <li><a href="/tabby">Tabby</a></li>
        
            <li><a href="/notty-notes">Notty Notes</a></li>
        
            <li><a href="/overapi-cheatsheet">OverAPI</a></li>
        
            <li><a href="/raining-in-chrome">听雨</a></li>
        
        </ul>
    </div>
</div>

<script src="/js/post.js" type="text/javascript"></script>


    <script type="text/javascript">
        $(function(){
            $('.home-follow').click(function(e){
                e.preventDefault();

                if($('.home-contact').is(':visible')){
                    $('.home-contact').slideUp(100);
                }else{
                    $('.home-contact').slideDown(100);
                }
            });
        })
    </script>
</body>
</html>
