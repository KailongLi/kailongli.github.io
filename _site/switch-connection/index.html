<!DOCTYPE html>
<html>
<head>
    <!--
    * Author:         BeiYuu
    -->
    <meta charset="utf-8" />
    <title>ONOS中控制器与交换机建立连接的过程 | kailongli.github.io</title>
    <meta name="author" content="KailongLi" />
    <meta name="renderer" content="webkit">
    <meta name="description" content="KailongLi's Blog" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0">
    <link rel="stylesheet" href="/css/default.css" type="text/css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon" />
    <link rel="alternate" type="application/atom+xml" title="Recent Entries" href="/atom.xml" />
    <script src="/js/jquery-1.7.1.min.js" type="text/javascript"></script>
</head>
<body>

    <div class="home-menu">
        <div class="home-icon-con">
            <a class="home-menu-icon" href="/">李开龙</a>
            <a class="home-follow" href="#" title="Contact Me">+</a>
        </div>
        <div class="home-contact">
            <a href="http://weibo.com/beiyuu/" target="_blank" style="margin-left:-5px;"><img src="http://www.weibo.com/favicon.ico" alt="" width="25"/></a>
            <a href="http://www.douban.com/people/beiyuu/" target="_blank" style="text-align:center;"><img src="http://www.douban.com/favicon.ico" alt="" width="22"/></a>
            <a href="http://instagram.com/beiyuu/" target="_blank" style="text-align:right"><img src="http://d36xtkk24g8jdx.cloudfront.net/bluebar/00c6602/images/ico/favicon.ico" alt="" width="22"/></a>
        </div>
    </div>

    <link rel="stylesheet" href="/js/prettify/prettify.css" />
<style type="text/css">
    body { background:#e8e8e8; }
    @media screen and (max-width: 750px){
        body { background:#fff; }
    }
    @media screen and (max-width: 1020px){
        body { background:#fff; }
    }
</style>

<div id="content">
    <div class="entry">
        <h1 class="entry-title"><a href="/switch-connection" title="ONOS中控制器与交换机建立连接的过程">ONOS中控制器与交换机建立连接的过程</a></h1>
        <p class="entry-date">2015-04-07</p>
        <p>控制器与交换机建立连接的过程主要分为三个阶段：控制器启动监听6633端口、交换机与控制器建立连接、控制器与交换机版本协商。
<img src="/images/githubpages/switch-connection-established.png" alt="switch connection established" /></p>

<h2>控制器启动监听6633端口</h2>

<p>控制器启动的入口函数为</p>

<pre><code>@Activate
OpenFlowControllerImpl.activate(Component context)
</code></pre>

<p>OSGI模块启动时候，就会调用这个函数，其中Activate注解说明了这一点：</p>

<pre><code>The Activate annotation defines the method which is used to activate the component.
</code></pre>

<p>在OpenFlowControllerImpl类初始化的过程中，首先会实例化Controller和内部类OpenFlowSwitchAgent，OpenFlowSwitchAgent类十分重要，它用于跟踪已经建立连接的交换机以及它处于的状态。</p>

<pre><code>private final Controller ctrl = new Controller();
protected OpenFlowSwitchAgent agent = new OpenFlowSwitchAgent();
</code></pre>

<p>然后启动控制器Controller.start(OpenFlowAgent agent)，主要是配置参数，启动server端，监听端口，等待交换机建立连接。</p>

<pre><code>public void run() {

    try {
        final ServerBootstrap bootstrap = createServerBootStrap();

        bootstrap.setOption("reuseAddr", true);
        bootstrap.setOption("child.keepAlive", true);
        bootstrap.setOption("child.tcpNoDelay", true);
        bootstrap.setOption("child.sendBufferSize", Controller.SEND_BUFFER_SIZE);

        ChannelPipelineFactory pfact =
                new OpenflowPipelineFactory(this, null);
        bootstrap.setPipelineFactory(pfact);
        InetSocketAddress sa = new InetSocketAddress(openFlowPort);
        cg = new DefaultChannelGroup();
        cg.add(bootstrap.bind(sa));

        log.info("Listening for switch connections on {}", sa);
    } catch (Exception e) {
        throw new RuntimeException(e);
    }
}
</code></pre>

<p>其中cg.add(bootstrap.bind(sa));表示控制器已经启动，并且开始监听相应的端口。代码看到这里，需要有<a href="http://www.importnew.com/7669.html" title="netty">netty</a> 的背景知识，下面将着重分析交换机连接控制器的代码。</p>

<h2>交换机与控制器建立连接</h2>

<p>上一段代码中比较重要的是</p>

<pre><code>ChannelPipelineFactory pfact =
                new OpenflowPipelineFactory(this, null);
</code></pre>

<p>这里将pipeline初始化为OpenFlowPipelineFactory，并且在OpenFlowPipelineFactory中重写ChannelPipelineFactory接口的getPipeline方法。</p>

<pre><code>public OpenflowPipelineFactory(Controller controller,
                               ThreadPoolExecutor pipelineExecutor) {
    super();
    this.controller = controller;
    this.pipelineExecutor = pipelineExecutor;
    this.timer = new HashedWheelTimer();
    this.idleHandler = new IdleStateHandler(timer, 20, 25, 0);
    this.readTimeoutHandler = new ReadTimeoutHandler(timer, 30);
}

@Override
public ChannelPipeline getPipeline() throws Exception {
    OFChannelHandler handler = new OFChannelHandler(controller);

    ChannelPipeline pipeline = Channels.pipeline();
    pipeline.addLast("ofmessagedecoder", new OFMessageDecoder());
    pipeline.addLast("ofmessageencoder", new OFMessageEncoder());
    pipeline.addLast("idle", idleHandler);
    pipeline.addLast("timeout", readTimeoutHandler);
    // XXX S ONOS: was 15 increased it to fix Issue #296
    pipeline.addLast("handshaketimeout",
                     new HandshakeTimeoutHandler(handler, timer, 60));
    if (pipelineExecutor != null) {
        pipeline.addLast("pipelineExecutor",
                         new ExecutionHandler(pipelineExecutor));
    }
    pipeline.addLast("handler", handler);
    return pipeline;
}
</code></pre>

<p>OpenflowPipelineFactory.getPipeline()方法作用：
为一个新的Channel创建一个新的ChannelPipeline，当一个server端的Channel接收到一个新的连接，我们会为每个新
的接受了的连接创建一个新的子Channel。这个新的子Channel使用一个新的ChannelPipeline，这个新的ChannelPipeline
由server端ChannelPipelineFactory的getPipeline创建。</p>

<p>在ChannelPipeline中，有idleHandler、readTimeoutHandler、HandshakeTimeoutHandler和handler这四个handler，其中
前三个handler用于超时处理，而第四个handler用于捕获这些超时产生的idleStateEvent(OFChannelHandler.channelIdle:
发送EchoRequest消息，OF心跳包)、readTimeoutException(OFChannelHandler.exceptionCaught：记录日志，关闭连接)、
HandshakeException(OFChannelHandler.exceptionCaught：记录日志，关闭连接)。</p>

<p>接下来分析这几个超时的设置：在初始化idleHandler的参数，this.idleHandler = new IdleStateHandler(timer, 20, 25, 0); 其中20表示读超时，意味着如果20秒内没有读到客户端发送的OF消息，则发送idleStateEvent给后面的handler处理，handler收到idleStateEvent之后，发送EchoRequest消息，这个消息是OF协议的心跳包。25表示如果25秒内没有发送OF消息给客户端，则触发同样的操作。this.readTimeoutHandler = new ReadTimeoutHandler(timer, 30);其中30表示如果30秒内没有读到OF消息，则抛出一个readTimeoutException给后面的handler处理，处理方法是断开连接。HandshakeTimeoutHandler(handler, timer, 60)，其中60意味着60需要完成握手过程，否则也是断开连接。由20和30这两个数字表明：如果20秒内没有收到心跳包，则控制器发送一个心跳包，交换机返回一个心跳包，控制器必须在30秒内必须收到回包，因此这意味着一个心跳周期最多不能超过10秒。<img src="/images/githubpages/channel%20timeout%20analysis.png" alt="channel timeout analysis" /></p>

<p>OFChannelHandler中主要关注复写SimpleChannelHandler类的channelConnected和messageReceived这两个方法，其中channelConnected用于处理Channel建立连接的ChannelStateEvent，messageReceived用于处理Channel接收到的MessageEvent。</p>

<pre><code>@Override
public void channelConnected(ChannelHandlerContext ctx,
        ChannelStateEvent e) throws Exception {
    channel = e.getChannel();
    log.info("New switch connection from {}",
            channel.getRemoteAddress());
    /*
        hack to wait for the switch to tell us what it's
        max version is. This is not spec compliant and should
        be removed as soon as switches behave better.
     */
    //sendHandshakeHelloMessage();
    setState(ChannelState.WAIT_HELLO);
}

@Override
public void messageReceived(ChannelHandlerContext ctx, MessageEvent e)
        throws Exception {
    if (e.getMessage() instanceof List) {
        @SuppressWarnings("unchecked")
        List&lt;OFMessage&gt; msglist = (List&lt;OFMessage&gt;) e.getMessage();

        for (OFMessage ofm : msglist) {
            // Do the actual packet processing
            state.processOFMessage(this, ofm);
        }
    } else {
        state.processOFMessage(this, (OFMessage) e.getMessage());
    }
}
</code></pre>

<p>在channelConnected方法中，控制器将自身的ChannelState设置为WAIT_HELLO，意为等待交换机发送hello消息，这种代码设计模式为<a href="http://www.importnew.com/7669.html" title="状态机模式">状态机模式</a>。下一篇博客将详细分析ChannelState的状态机运转。接着在messageReceived方法中，对每个接收到的OF消息进行处理。到这里，交换机与控制器已经建立了TCP连接，接下来，将分析控制器和交换机握手的过程，即版本协商。</p>

<h2>控制器与交换机进行版本协商</h2>

<p>在ChannelState为WAIT_HELLO状态下，控制器一旦收到OF Hello的消息，便会调用processOFHello方法，在这个方法中，进行<a href="http://flowgrammable.org/sdn/openflow/state-machine/" title="版本协商">版本协商</a>，如果协商失败，控制器则会主动断开连接。从代码中可以看出：
<li>控制器目前只支持OF10和OF13协议</li>
<li>检查版本bitmap来进行的代码还没开发</li></p>

<pre><code>@Override
void processOFHello(OFChannelHandler h, OFHello m)
        throws IOException {
    // TODO We could check for the optional bitmap, but for now
    // we are just checking the version number.
    if (m.getVersion() == OFVersion.OF_13) {
        log.debug("Received {} Hello from {}", m.getVersion(),
                h.channel.getRemoteAddress());
        h.sendHandshakeHelloMessage();
        h.ofVersion = OFVersion.OF_13;
    } else if (m.getVersion() == OFVersion.OF_10) {
        log.debug("Received {} Hello from {} - switching to OF "
                + "version 1.0", m.getVersion(),
                h.channel.getRemoteAddress());
        OFHello hi =
                h.factory10.buildHello()
                        .setXid(h.handshakeTransactionIds--)
                        .build();
        h.channel.write(Collections.singletonList(hi));
        h.ofVersion = OFVersion.OF_10;
    } else {
        log.error("Received Hello of version {} from switch at {}. "
                + "This controller works with OF1.0 and OF1.3 "
                + "switches. Disconnecting switch ...",
                m.getVersion(), h.channel.getRemoteAddress());
        h.channel.disconnect();
        return;
    }
    h.sendHandshakeFeaturesRequestMessage();
    h.setState(WAIT_FEATURES_REPLY);
}
</code></pre>

    </div>

    <div class="sidenav">
        <iframe width="100%" height="75" class="share_self"  frameborder="0" scrolling="no" src="http://widget.weibo.com/weiboshow/index.php?language=&width=0&height=75&fansRow=2&ptype=1&speed=0&skin=5&isTitle=0&noborder=0&isWeibo=0&isFans=0&uid=1855270953&verifier=375b89d6&dpc=1"></iframe>
    </div>

    <div class="sidenav">
        <h2>Blog</h2>
        <ul class="artical-list">
        
            <li><a href="/event-processing">ONOS 事件处理机制</a></li>
        
            <li><a href="/provider-providerRegistry-providerService">ONOS 南向抽象层分析</a></li>
        
            <li><a href="/dispatch-message">ONOS中收到OF消息后，分发消息流程分析</a></li>
        
            <li><a href="/channel-state">ONOS中Channel状态机分析</a></li>
        
            <li><a href="/switch-connection">ONOS中控制器与交换机建立连接的过程</a></li>
        
            <li><a href="/github-pages">使用Github Pages建独立博客</a></li>
        
            <li><a href="/why-blog">我为什么写博客？</a></li>
        
        </ul>

        <h2>Opinion</h2>
        <ul class="artical-list">
        
            <li><a href="/about-simplify">胡言乱语说简单</a></li>
        
        </ul>

        <h2>Project</h2>
        <ul class="artical-list">
        
            <li><a href="/tabby">Tabby</a></li>
        
            <li><a href="/notty-notes">Notty Notes</a></li>
        
            <li><a href="/overapi-cheatsheet">OverAPI</a></li>
        
            <li><a href="/raining-in-chrome">听雨</a></li>
        
        </ul>
    </div>
</div>

<script src="/js/post.js" type="text/javascript"></script>


    <script type="text/javascript">
        $(function(){
            $('.home-follow').click(function(e){
                e.preventDefault();

                if($('.home-contact').is(':visible')){
                    $('.home-contact').slideUp(100);
                }else{
                    $('.home-contact').slideDown(100);
                }
            });
        })
    </script>
</body>
</html>
